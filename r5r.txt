DESCRIPTION:
Type: Package
Package: r5r
Title: Rapid Realistic Routing with 'R5'
Version: 2.1.0
Authors@R: c(
    person("Marcus", "Saraiva", , "marcus.saraiva@gmail.com", role = "aut",
           comment = c(ORCID = "0000-0001-6218-2338")),
    person("Rafael H. M.", "Pereira", , "rafa.pereira.br@gmail.com", role = c("aut", "cre"),
           comment = c(ORCID = "0000-0003-2125-7465")),
    person("Daniel", "Herszenhut", , "dhersz@gmail.com", role = "aut",
           comment = c(ORCID = "0000-0001-8066-1105")),
    person("Carlos Kaue Vieira", "Braga", , "kaue@kauebraga.dev", role = "aut",
           comment = c(ORCID = "0000-0002-6104-7297")),
    person("Matthew Wigginton", "Bhagat-Conway", , "mwbc@unc.edu", role = "aut",
           comment = c(ORCID = "0000-0002-1210-2982")),
    person("Luyu", "Liu", , "luyuliu@ufl.edu", role = "ctb",
           comment = c(ORCID = "0000-0002-6684-5570")),
    person("Ipea - Institute for Applied Economic Research", role = c("cph", "fnd"))
  )
Description: Rapid realistic routing on multimodal transport networks
    (walk, bike, public transport and car) using 'R5', the Rapid Realistic
    Routing on Real-world and Reimagined networks engine
    <https://github.com/conveyal/r5>. The package allows users to generate
    detailed routing analysis or calculate travel time and monetary cost matrices 
    using seamless parallel computing on top of the R5 Java machine.  While R5
    is developed by Conveyal, the package r5r is independently developed
    by a team at the Institute for Applied Economic Research (Ipea) with
    contributions from collaborators. Apart from the documentation in this
    package, users will find additional information on R5 documentation at
    <https://docs.conveyal.com/>. Although we try to keep new releases of
    r5r in synchrony with R5, the development of R5 follows Conveyal's
    independent update process. Hence, users should confirm the R5 version
    implied by the Conveyal user manual (see
    <https://docs.conveyal.com/changelog>) corresponds with the R5 version
    that r5r depends on. This version of r5r depends on R5 v7.1.
License: MIT + file LICENSE
URL: https://github.com/ipeaGIT/r5r, https://ipeagit.github.io/r5r/
BugReports: https://github.com/ipeaGIT/r5r/issues
Depends: R (>= 3.6)
Imports: checkmate, cli, concaveman, data.table, jsonlite, rJava (>=
        0.9-10), rlang, sf (>= 1.0-12), sfheaders, utils, zip
Suggests: accessibility, covr, dplyr, ggplot2 (>= 3.3.1), gtfstools,
        h3jsr (>= 1.3.0), interp, knitr, parallel, patchwork, rJavaEnv,
        rmarkdown, testthat
VignetteBuilder: knitr
Encoding: UTF-8
RoxygenNote: 7.3.2
SystemRequirements: Java JDK (>= 21.0)
NeedsCompilation: no
Packaged: 2025-03-08 18:05:28 UTC; user
Author: Marcus Saraiva [aut] (<https://orcid.org/0000-0001-6218-2338>),
  Rafael H. M. Pereira [aut, cre]
    (<https://orcid.org/0000-0003-2125-7465>),
  Daniel Herszenhut [aut] (<https://orcid.org/0000-0001-8066-1105>),
  Carlos Kaue Vieira Braga [aut]
    (<https://orcid.org/0000-0002-6104-7297>),
  Matthew Wigginton Bhagat-Conway [aut]
    (<https://orcid.org/0000-0002-1210-2982>),
  Luyu Liu [ctb] (<https://orcid.org/0000-0002-6684-5570>),
  Ipea - Institute for Applied Economic Research [cph, fnd]
Maintainer: Rafael H. M. Pereira <rafa.pereira.br@gmail.com>
Repository: CRAN
Date/Publication: 2025-03-08 21:40:02 UTC

--------------------------------------------------------------------------------
Function: accessibility()
Calculate access to opportunities

Description:

     Fast computation of access to opportunities given a selected decay
     function.

Usage:

     accessibility(
       r5r_core,
       origins,
       destinations,
       opportunities_colnames = "opportunities",
       mode = "WALK",
       mode_egress = "WALK",
       departure_datetime = Sys.time(),
       time_window = 10L,
       percentiles = 50L,
       decay_function = "step",
       cutoffs = NULL,
       decay_value = NULL,
       fare_structure = NULL,
       max_fare = Inf,
       max_walk_time = Inf,
       max_bike_time = Inf,
       max_car_time = Inf,
       max_trip_duration = 120L,
       walk_speed = 3.6,
       bike_speed = 12,
       max_rides = 3,
       max_lts = 2,
       draws_per_minute = 5L,
       n_threads = Inf,
       verbose = FALSE,
       progress = FALSE,
       output_dir = NULL
     )
     
Arguments:

r5r_core: An object to connect with the R5 routing engine, created with
          ‘setup_r5()’.

origins, destinations: Either a POINT sf object with WGS84 CRS, or a
          ‘data.frame’ containing the columns ‘id’, ‘lon’ and ‘lat’.

opportunities_colnames: A character vector. The names of the columns in
          the ‘destinations’ input that tells the number of
          opportunities in each location. Several different column
          names can be passed, in which case the accessibility to each
          kind of opportunity will be calculated.

    mode: A character vector. The transport modes allowed for access,
          transfer and vehicle legs of the trips. Defaults to ‘WALK’.
          Please see details for other options.

mode_egress: A character vector. The transport mode used after egress
          from the last public transport. It can be either ‘WALK’,
          ‘BICYCLE’ or ‘CAR’. Defaults to ‘WALK’. Ignored when public
          transport is not used.

departure_datetime: A POSIXct object. Please note that the departure
          time only influences public transport legs. When working with
          public transport networks, please check the ‘calendar.txt’
          within your GTFS feeds for valid dates. Please see details
          for further information on how datetimes are parsed.

time_window: An integer. The time window in minutes for which ‘r5r’
          will calculate multiple travel time matrices departing each
          minute. Defaults to 10 minutes. By default, the function
          returns the result based on median travel times, but the user
          can set the ‘percentiles’ parameter to extract more results.
          Please read the time window vignette for more details on its
          usage ‘vignette("time_window", package = "r5r")’

percentiles: An integer vector (max length of 5). Specifies the
          percentile to use when returning accessibility estimates
          within the given time window. Please note that this parameter
          is applied to the travel time estimates that generate the
          accessibility results, and not to the accessibility
          distribution itself (i.e. if the 25th percentile is
          specified, the accessibility is calculated from the 25th
          percentile travel time, which may or may not be equal to the
          25th percentile of the accessibility distribution itself).
          Defaults to 50, returning the accessibility calculated from
          the median travel time. If a vector with length bigger than 1
          is passed, the output contains an additional column that
          specifies the percentile of each accessibility estimate. Due
          to upstream restrictions, only 5 percentiles can be specified
          at a time. For more details, please see ‘R5’ documentation at
          <https://docs.conveyal.com/analysis/methodology#accounting-for-variability>.

decay_function: A string. Which decay function to use when calculating
          accessibility. One of ‘step’, ‘exponential’,
          ‘fixed_exponential’, ‘linear’ or ‘logistic’. Defaults to
          ‘step’, which is equivalent to a cumulative opportunities
          measure. Please see the details to understand how each
          alternative works and how they relate to the ‘cutoffs’ and
          ‘decay_value’ parameters.

 cutoffs: A numeric vector (maximum length of 12). This parameter has
          different effects for each decay function: it indicates the
          cutoff times in minutes when calculating cumulative
          opportunities accessibility with the ‘step’ function, the
          median (or inflection point) of the decay curves in the
          ‘logistic’ and ‘linear’ functions, and the half-life in the
          ‘exponential’ function. It has no effect when using the
          ‘fixed_exponential’ function.

decay_value: A number. Extra parameter to be passed to the selected
          ‘decay_function’. Has no effects when ‘decay_function’ is
          either ‘step’ or ‘exponential’.

fare_structure: A fare structure object, following the convention set
          in ‘setup_fare_structure()’. This object describes how
          transit fares should be calculated. Please see the fare
          structure vignette to understand how this object is
          structured: ‘vignette("fare_structure", package = "r5r")’.

max_fare: A number. The maximum value that trips can cost when
          calculating the fastest journey between each origin and
          destination pair.

max_walk_time: An integer. The maximum walking time (in minutes) to
          access and egress the transit network, to make transfers
          within the network or to complete walk-only trips. Defaults
          to no restrictions (numeric value of ‘Inf’), as long as
          ‘max_trip_duration’ is respected. When routing transit trips,
          the max time is considered separately for each leg (e.g. if
          you set ‘max_walk_time’ to 15, you could get trips with an up
          to 15 minutes walk leg to reach transit and another up to 15
          minutes walk leg to reach the destination after leaving
          transit. In walk-only trips, whenever ‘max_walk_time’ differs
          from ‘max_trip_duration’, the lowest value is considered.

max_bike_time: An integer. The maximum cycling time (in minutes) to
          access and egress the transit network, to make transfers
          within the network or to complete bicycle-only trips.
          Defaults to no restrictions (numeric value of ‘Inf’), as long
          as ‘max_trip_duration’ is respected. When routing transit
          trips, the max time is considered separately for each leg
          (e.g. if you set ‘max_bike_time’ to 15, you could get trips
          with an up to 15 minutes cycle leg to reach transit and
          another up to 15 minutes cycle leg to reach the destination
          after leaving transit. In bicycle-only trips, whenever
          ‘max_bike_time’ differs from ‘max_trip_duration’, the lowest
          value is considered.

max_car_time: An integer. The maximum driving time (in minutes) to
          access and egress the transit network. Defaults to no
          restrictions, as long as ‘max_trip_duration’ is respected.
          The max time is considered separately for each leg (e.g. if
          you set ‘max_car_time’ to 15 minutes, you could potentially
          drive up to 15 minutes to reach transit, and up to _another_
          15 minutes to reach the destination after leaving transit).
          Defaults to ‘Inf’, no limit.

max_trip_duration: An integer. The maximum trip duration in minutes.
          Defaults to 120 minutes (2 hours).

walk_speed: A numeric. Average walk speed in km/h. Defaults to 3.6
          km/h.

bike_speed: A numeric. Average cycling speed in km/h. Defaults to 12
          km/h.

max_rides: An integer. The maximum number of public transport rides
          allowed in the same trip. Defaults to 3.

 max_lts: An integer between 1 and 4. The maximum level of traffic
          stress that cyclists will tolerate. A value of 1 means
          cyclists will only travel through the quietest streets, while
          a value of 4 indicates cyclists can travel through any road.
          Defaults to 2. Please see details for more information.

draws_per_minute: An integer. The number of Monte Carlo draws to
          perform per time window minute when calculating travel time
          matrices and when estimating accessibility. Defaults to 5.
          This would mean 300 draws in a 60-minute time window, for
          example. This parameter only affects the results when the
          GTFS feeds contain a ‘frequencies.txt’ table. If the GTFS
          feed does not have a frequency table, r5r still allows for
          multiple runs over the set ‘time_window’ but in a
          deterministic way.

n_threads: An integer. The number of threads to use when running the
          router in parallel. Defaults to use all available threads
          (Inf).

 verbose: A logical. Whether to show ‘R5’ informative messages when
          running the function. Defaults to ‘FALSE’ (please note that
          in such case ‘R5’ error messages are still shown). Setting
          ‘verbose’ to ‘TRUE’ shows detailed output, which can be
          useful for debugging issues not caught by ‘r5r’.

progress: A logical. Whether to show a progress counter when running
          the router. Defaults to ‘FALSE’. Only works when ‘verbose’ is
          set to ‘FALSE’, so the progress counter does not interfere
          with ‘R5’'s output messages. Setting ‘progress’ to ‘TRUE’ may
          impose a small penalty for computation efficiency, because
          the progress counter must be synchronized among all active
          threads.

output_dir: Either ‘NULL’ or a path to an existing directory. When not
          ‘NULL’ (the default), the function will write one ‘.csv’ file
          with the results for each origin in the specified directory.
          In such case, the function returns the path specified in this
          parameter. This parameter is particularly useful when running
          on memory-constrained settings because writing the results
          directly to disk prevents ‘r5r’ from loading them to RAM
          memory.

Value:

     A ‘data.table’ with accessibility estimates for all origin points.
     This ‘data.table’ contain columns listing the origin id, the type
     of opportunities to which accessibility was calculated, the travel
     time percentile considered in the accessibility estimate and the
     specified cutoff values (except in when ‘decay_function’ is
     ‘fixed_exponential’, in which case the ‘cutoff’ parameter is not
     used). If ‘output_dir’ is not ‘NULL’, the function returns the
     path specified in that parameter, in which the ‘.csv’ files
     containing the results are saved.

Decay functions:

     ‘R5’ allows one to use different decay functions when calculating
     accessibility. Please see the original ‘R5’ documentation from
     Conveyal for more information on each one one
     (<https://docs.conveyal.com/learn-more/decay-functions>). A
     summary of each available option, as well as the value passed to
     ‘decay_function’ to use it (inside parentheses) are listed below:

        • *Step*, also known as cumulative opportunities (‘"step"’):
          a binary decay function used to find the sum of available
          opportunities within a specific travel time cutoff.

        • *Logistic CDF* (‘"logistic"’):
          This is the logistic function, i.e. the cumulative
          distribution function of the logistic distribution, expressed
          such that its parameters are the median (inflection point)
          and standard deviation. This function applies a sigmoid
          rolloff that has a convenient relationship to discrete choice
          theory. Its parameters can be set to reflect a whole
          population's tolerance for making trips with different travel
          times. The function's value represents the probability that a
          randomly chosen member of the population would accept making
          a trip, given its duration. Opportunities are then weighted
          by how likely it is that a person would consider them
          "reachable".

            • Calibration: The median parameter is controlled by the
              ‘cutoff’ parameter, leaving only the standard deviation
              to configure through the ‘decay_value’ parameter.

        • *Fixed Exponential* (‘"fixed_exponential"’):
          This function is of the form ‘exp(-Lt)’ where L is a single
          fixed decay constant in the range (0, 1). It is constrained
          to be positive to ensure weights decrease (rather than grow)
          with increasing travel time.

            • Calibration: This function is controlled exclusively by
              the ‘L’ constant, given by the ‘decay_value’ parameter.
              Values provided in ‘cutoffs’ are ignored.

        • *Half-life Exponential Decay* (‘"exponential"’):
          This is similar to the fixed-exponential option above, but in
          this case the decay parameter is inferred from the ‘cutoffs’
          parameter values, which is treated as the half-life of the
          decay.

        • *Linear* (‘"linear"’):
          This is a simple, vaguely sigmoid option, which may be useful
          when you have a sense of a maximum travel time that would be
          tolerated by any traveler, and a minimum time below which all
          travel is perceived to be equally easy.

            • Calibration: The transition region is transposable and
              symmetric around the ‘cutoffs’ parameter values, taking
              ‘decay_value’ minutes to taper down from one to zero.

Transport modes:

     ‘R5’ allows for multiple combinations of transport modes. The
     options include:

        • *Transit modes:* ‘TRAM’, ‘SUBWAY’, ‘RAIL’, ‘BUS’, ‘FERRY’,
          ‘CABLE_CAR’, ‘GONDOLA’, ‘FUNICULAR’. The option ‘TRANSIT’
          automatically considers all public transport modes available.

        • *Non transit modes:* ‘WALK’, ‘BICYCLE’, ‘CAR’,
          ‘BICYCLE_RENT’, ‘CAR_PARK’.

Level of Traffic Stress (LTS):

     When cycling is enabled in ‘R5’ (by passing the value ‘BIKE’ to
     either ‘mode’ or ‘mode_egress’), setting ‘max_lts’ will allow
     cycling only on streets with a given level of danger/stress.
     Setting ‘max_lts’ to 1, for example, will allow cycling only on
     separated bicycle infrastructure or low-traffic streets and
     routing will revert to walking when traversing any links with LTS
     exceeding 1. Setting ‘max_lts’ to 3 will allow cycling on links
     with LTS 1, 2 or 3. Routing also reverts to walking if the street
     segment is tagged as non-bikable in OSM (e.g. a staircase),
     independently of the specified max LTS.

     The default methodology for assigning LTS values to network edges
     is based on commonly tagged attributes of OSM ways. See more info
     about LTS in the original documentation of R5 from Conveyal at
     <https://docs.conveyal.com/learn-more/traffic-stress>. In summary:

        • *LTS 1*: Tolerable for children. This includes low-speed,
          low-volume streets, as well as those with separated bicycle
          facilities (such as parking-protected lanes or cycle tracks).

        • *LTS 2*: Tolerable for the mainstream adult population. This
          includes streets where cyclists have dedicated lanes and only
          have to interact with traffic at formal crossing.

        • *LTS 3*: Tolerable for "enthused and confident" cyclists.
          This includes streets which may involve close proximity to
          moderate- or high-speed vehicular traffic.

        • *LTS 4*: Tolerable only for "strong and fearless" cyclists.
          This includes streets where cyclists are required to mix with
          moderate- to high-speed vehicular traffic.

     For advanced users, you can provide custom LTS values by adding a
     tag <key = "lts"> to the ‘osm.pbf’ file.

Datetime parsing:

     ‘r5r’ ignores the timezone attribute of datetime objects when
     parsing dates and times, using the study area's timezone instead.
     For example, let's say you are running some calculations using Rio
     de Janeiro, Brazil, as your study area. The datetime
     ‘as.POSIXct("13-05-2019 14:00:00", format = "%d-%m-%Y %H:%M:%S")’
     will be parsed as May 13th, 2019, 14:00h in Rio's local time, as
     expected. But ‘as.POSIXct("13-05-2019 14:00:00", format =
     "%d-%m-%Y %H:%M:%S", tz = "Europe/Paris")’ will also be parsed as
     the exact same date and time in Rio's local time, perhaps
     surprisingly, ignoring the timezone attribute.

Routing algorithm:

     The ‘travel_time_matrix()’, ‘expanded_travel_time_matrix()’ and
     ‘accessibility()’ functions use an ‘R5’-specific extension to the
     RAPTOR routing algorithm (see Conway et al., 2017). This RAPTOR
     extension uses a systematic sample of one departure per minute
     over the time window set by the user in the 'time_window'
     parameter. A detailed description of base RAPTOR can be found in
     Delling et al (2015). However, whenever the user includes transit
     fares inputs to these functions, they automatically switch to use
     an ‘R5’-specific extension to the McRAPTOR routing algorithm.

        • Conway, M. W., Byrd, A., & van der Linden, M. (2017).
          Evidence-based transit and land use sketch planning using
          interactive accessibility methods on combined schedule and
          headway-based networks. Transportation Research Record,
          2653(1), 45-53.
          \Sexpr[results=rd]{tools:::Rd_expr_doi("10.3141/2653-06")}

        • Delling, D., Pajor, T., & Werneck, R. F. (2015). Round-based
          public transit routing. Transportation Science, 49(3),
          591-604.
          \Sexpr[results=rd]{tools:::Rd_expr_doi("10.1287/trsc.2014.0534")}

Examples:

     library(r5r)
     
     data_path <- system.file("extdata/poa", package = "r5r")
     r5r_core <- setup_r5(data_path)
     points <- read.csv(file.path(data_path, "poa_hexgrid.csv"))[1:5, ]
     
     departure_datetime <- as.POSIXct(
       "13-05-2019 14:00:00",
       format = "%d-%m-%Y %H:%M:%S"
     )
     
     access <- accessibility(
       r5r_core,
       origins = points,
       destinations = points,
       opportunities_colnames = "schools",
       mode = "WALK",
       departure_datetime = departure_datetime,
       decay_function = "step",
       cutoffs = 30,
       max_trip_duration = 30
     )
     head(access)
     
     # using a different decay function
     access <- accessibility(
       r5r_core,
       origins = points,
       destinations = points,
       opportunities_colnames = "schools",
       mode = "WALK",
       departure_datetime = departure_datetime,
       decay_function = "logistic",
       cutoffs = 30,
       decay_value = 1,
       max_trip_duration = 30
     )
     head(access)
     
     # using several cutoff values
     access <- accessibility(
       r5r_core,
       origins = points,
       destinations = points,
       opportunities_colnames = "schools",
       mode = "WALK",
       departure_datetime = departure_datetime,
       decay_function = "step",
       cutoffs = c(15, 30),
       max_trip_duration = 30
     )
     head(access)
     
     # calculating access to different types of opportunities
     access <- accessibility(
       r5r_core,
       origins = points,
       destinations = points,
       opportunities_colnames = c("schools", "healthcare"),
       mode = "WALK",
       departure_datetime = departure_datetime,
       decay_function = "step",
       cutoffs = 30,
       max_trip_duration = 30
     )
     head(access)
     
     stop_r5(r5r_core)
     

--------------------------------------------------------------------------------
Function: assert_fare_structure()
Assert fare structure

Description:

     Asserts whether the specified fare structure object complies with
     the structure set in ‘setup_fare_structure()’.

Usage:

     assert_fare_structure(fare_structure)
     
Arguments:

fare_structure: A fare structure object, following the convention set
          in ‘setup_fare_structure()’. This object describes how
          transit fares should be calculated. Please see the fare
          structure vignette to understand how this object is
          structured: ‘vignette("fare_structure", package = "r5r")’.

Value:

     Throws and error upon failure and invisibly returns ‘TRUE’ on
     success.


--------------------------------------------------------------------------------
Function: assign_decay_function()
Assign decay function and parameter values

Description:

     Checks and assigns decay function and values.

Usage:

     assign_decay_function(decay_function, decay_value)
     
Arguments:

decay_function: A string, the name of the decay function.

decay_value: A number, the value of decay parameter.

Value:

     A ‘list’ with the validated decay function and parameter value.

See Also:

     Other assigning functions: ‘assign_departure()’,
     ‘assign_drop_geometry()’, ‘assign_max_street_time()’,
     ‘assign_max_trip_duration()’, ‘assign_mode()’,
     ‘assign_opportunities()’, ‘assign_points_input()’,
     ‘assign_shortest_path()’


--------------------------------------------------------------------------------
Function: assign_departure()
Check and convert POSIXct objects to strings

Description:

     Check and convert POSIXct objects to strings

Usage:

     assign_departure(datetime)
     
Arguments:

datetime: An object of POSIXct class.

Value:

     A list with the ‘date’ and ‘time’ of the trip departure as
     characters.

See Also:

     Other assigning functions: ‘assign_decay_function()’,
     ‘assign_drop_geometry()’, ‘assign_max_street_time()’,
     ‘assign_max_trip_duration()’, ‘assign_mode()’,
     ‘assign_opportunities()’, ‘assign_points_input()’,
     ‘assign_shortest_path()’


--------------------------------------------------------------------------------
Function: assign_drop_geometry()
Assign drop geometry

Description:

     Check the drop geometry input.

Usage:

     assign_drop_geometry(drop_geometry)
     
Arguments:

drop_geometry: A logical.

Value:

     A logical.

See Also:

     Other assigning functions: ‘assign_decay_function()’,
     ‘assign_departure()’, ‘assign_max_street_time()’,
     ‘assign_max_trip_duration()’, ‘assign_mode()’,
     ‘assign_opportunities()’, ‘assign_points_input()’,
     ‘assign_shortest_path()’


--------------------------------------------------------------------------------
Function: assign_max_street_time()
Assign max street time from walk/bike distance and speed

Description:

     Checks the time duration and speed inputs and converts them to
     distance.

Usage:

     assign_max_street_time(max_time, speed, max_trip_duration, mode)
     
Arguments:

max_time: A numeric of length 1. Maximum walking distance (in meters)
          for the whole trip. Passed from routing functions.

   speed: A numeric of length 1. Average walk speed in km/h. Defaults
          to 3.6 Km/h. Passed from routing functions.

max_trip_duration: A numeric of length 1. Maximum trip duration in
          seconds. Defaults to 120 minutes (2 hours). Passed from
          routing functions.

    mode: A string. Either ‘"bike"’ or ‘"walk"’.

Value:

     An ‘integer’ representing the maximum number of minutes walking.

See Also:

     Other assigning functions: ‘assign_decay_function()’,
     ‘assign_departure()’, ‘assign_drop_geometry()’,
     ‘assign_max_trip_duration()’, ‘assign_mode()’,
     ‘assign_opportunities()’, ‘assign_points_input()’,
     ‘assign_shortest_path()’


--------------------------------------------------------------------------------
Function: assign_max_trip_duration()
Assign max trip duration

Description:

     Check and convert the max trip duration input.

Usage:

     assign_max_trip_duration(
       max_trip_duration,
       modes,
       max_walk_time,
       max_bike_time
     )
     
Arguments:

max_trip_duration: A number.

Value:

     An ‘integer’ representing the maximum trip duration in minutes.

See Also:

     Other assigning functions: ‘assign_decay_function()’,
     ‘assign_departure()’, ‘assign_drop_geometry()’,
     ‘assign_max_street_time()’, ‘assign_mode()’,
     ‘assign_opportunities()’, ‘assign_points_input()’,
     ‘assign_shortest_path()’


--------------------------------------------------------------------------------
Function: assign_mode()
Check and select transport modes from user input

Description:

     Selects the transport modes used in the routing functions. Only
     one direct and access/egress modes are allowed at a time.

Usage:

     assign_mode(mode, mode_egress, style)
     
Arguments:

    mode: A character vector, passed from routing functions.

mode_egress: A character vector, passed from routing functions.

Value:

     A list with the transport modes to be used in the routing.

See Also:

     Other assigning functions: ‘assign_decay_function()’,
     ‘assign_departure()’, ‘assign_drop_geometry()’,
     ‘assign_max_street_time()’, ‘assign_max_trip_duration()’,
     ‘assign_opportunities()’, ‘assign_points_input()’,
     ‘assign_shortest_path()’


--------------------------------------------------------------------------------
Function: assign_opportunities()
Assign opportunities data

Description:

     Check and create an opportunities dataset.

Usage:

     assign_opportunities(destinations, opportunities_colnames)
     
Arguments:

destinations: Either a ‘data.frame’ or a POINT sf.

opportunities_colnames: A character vector with the names of the
          opportunities columns in ‘destinations’.

Value:

     A list of ‘Java-Array’ objects.

See Also:

     Other assigning functions: ‘assign_decay_function()’,
     ‘assign_departure()’, ‘assign_drop_geometry()’,
     ‘assign_max_street_time()’, ‘assign_max_trip_duration()’,
     ‘assign_mode()’, ‘assign_points_input()’, ‘assign_shortest_path()’


--------------------------------------------------------------------------------
Function: assign_points_input()
Check and convert origin and destination inputs

Description:

     Check and convert origin and destination inputs

Usage:

     assign_points_input(df, name)
     
Arguments:

      df: Either a ‘data.frame’ or a POINT sf.

    name: Object name.

Value:

     A ‘data.frame’ with columns ‘id’, ‘lon’ and ‘lat’.

See Also:

     Other assigning functions: ‘assign_decay_function()’,
     ‘assign_departure()’, ‘assign_drop_geometry()’,
     ‘assign_max_street_time()’, ‘assign_max_trip_duration()’,
     ‘assign_mode()’, ‘assign_opportunities()’,
     ‘assign_shortest_path()’


--------------------------------------------------------------------------------
Function: assign_shortest_path()
Assign shortest path

Description:

     Check the shortest path input.

Usage:

     assign_shortest_path(shortest_path)
     
Arguments:

shortest_path: A logical.

Value:

     A logical.

See Also:

     Other assigning functions: ‘assign_decay_function()’,
     ‘assign_departure()’, ‘assign_drop_geometry()’,
     ‘assign_max_street_time()’, ‘assign_max_trip_duration()’,
     ‘assign_mode()’, ‘assign_opportunities()’, ‘assign_points_input()’


--------------------------------------------------------------------------------
Function: detailed_itineraries()
Detailed itineraries between origin-destination pairs

Description:

     Returns detailed trip information between origin-destination
     pairs. The output includes the waiting and moving time in each
     trip leg, as well as some info such as the distance traveled, the
     routes used and the geometry of each leg. Please note that this
     function was originally conceptualized as a trip planning
     functionality, similar to other commercial and non-commercial APIs
     and apps (e.g. Moovit, Google's Directions API, OpenTripPlanning's
     PlannerResource API). Thus, it consumes much more time and memory
     than the other (more analytical) routing functions included in the
     package.

Usage:

     detailed_itineraries(
       r5r_core,
       origins,
       destinations,
       mode = "WALK",
       mode_egress = "WALK",
       departure_datetime = Sys.time(),
       time_window = 10L,
       suboptimal_minutes = 0L,
       fare_structure = NULL,
       max_fare = Inf,
       max_walk_time = Inf,
       max_bike_time = Inf,
       max_car_time = Inf,
       max_trip_duration = 120L,
       walk_speed = 3.6,
       bike_speed = 12,
       max_rides = 3,
       max_lts = 2,
       shortest_path = TRUE,
       all_to_all = FALSE,
       n_threads = Inf,
       verbose = FALSE,
       progress = FALSE,
       drop_geometry = FALSE,
       output_dir = NULL
     )
     
Arguments:

r5r_core: An object to connect with the R5 routing engine, created with
          ‘setup_r5()’.

origins, destinations: Either a POINT sf object with WGS84 CRS, or a
          ‘data.frame’ containing the columns ‘id’, ‘lon’ and ‘lat’.

    mode: A character vector. The transport modes allowed for access,
          transfer and vehicle legs of the trips. Defaults to ‘WALK’.
          Please see details for other options.

mode_egress: A character vector. The transport mode used after egress
          from the last public transport. It can be either ‘WALK’,
          ‘BICYCLE’ or ‘CAR’. Defaults to ‘WALK’. Ignored when public
          transport is not used.

departure_datetime: A POSIXct object. Please note that the departure
          time only influences public transport legs. When working with
          public transport networks, please check the ‘calendar.txt’
          within your GTFS feeds for valid dates. Please see details
          for further information on how datetimes are parsed.

time_window: An integer. The time window in minutes for which ‘r5r’
          will calculate multiple itineraries departing each minute.
          Defaults to 10 minutes. If the same sequence of routes appear
          in different minutes of the time window, only the fastest of
          them will be kept in the output. This happens because the
          result is not aggregated by percentile, as opposed to other
          routing functions in the package. Because of that, the output
          may contain trips departing after the specified
          ‘departure_datetime’, but still within the time window.
          Please read the time window vignette for more details on how
          this argument affects the results of each routing function:
          ‘vignette("time_window", package = "r5r")’.

suboptimal_minutes: A number. The difference in minutes that each
          non-optimal RAPTOR branch can have from the optimal branch
          without being disregarded by the routing algorithm. If, for
          example, users set ‘suboptimal_minutes = 10’, the routing
          algorithm will consider sub-optimal routes that arrive up to
          10 minutes after the arrival of the optimal one. This
          argument emulates the real-life behaviour that makes people
          want to take a path that is technically not optimal in terms
          of travel time, for example, for some practical reasons (e.g.
          mode preference, safety, etc). In practice, the higher this
          value, the more itineraries will be returned in the final
          result.

fare_structure: A fare structure object, following the convention set
          in ‘setup_fare_structure()’. This object describes how
          transit fares should be calculated. Please see the fare
          structure vignette to understand how this object is
          structured: ‘vignette("fare_structure", package = "r5r")’.

max_fare: A number. The maximum value that trips can cost when
          calculating the fastest journey between each origin and
          destination pair.

max_walk_time: An integer. The maximum walking time (in minutes) to
          access and egress the transit network, to make transfers
          within the network or to complete walk-only trips. Defaults
          to no restrictions (numeric value of ‘Inf’), as long as
          ‘max_trip_duration’ is respected. When routing transit trips,
          the max time is considered separately for each leg (e.g. if
          you set ‘max_walk_time’ to 15, you could get trips with an up
          to 15 minutes walk leg to reach transit and another up to 15
          minutes walk leg to reach the destination after leaving
          transit. In walk-only trips, whenever ‘max_walk_time’ differs
          from ‘max_trip_duration’, the lowest value is considered.

max_bike_time: An integer. The maximum cycling time (in minutes) to
          access and egress the transit network, to make transfers
          within the network or to complete bicycle-only trips.
          Defaults to no restrictions (numeric value of ‘Inf’), as long
          as ‘max_trip_duration’ is respected. When routing transit
          trips, the max time is considered separately for each leg
          (e.g. if you set ‘max_bike_time’ to 15, you could get trips
          with an up to 15 minutes cycle leg to reach transit and
          another up to 15 minutes cycle leg to reach the destination
          after leaving transit. In bicycle-only trips, whenever
          ‘max_bike_time’ differs from ‘max_trip_duration’, the lowest
          value is considered.

max_car_time: An integer. The maximum driving time (in minutes) to
          access and egress the transit network. Defaults to no
          restrictions, as long as ‘max_trip_duration’ is respected.
          The max time is considered separately for each leg (e.g. if
          you set ‘max_car_time’ to 15 minutes, you could potentially
          drive up to 15 minutes to reach transit, and up to _another_
          15 minutes to reach the destination after leaving transit).
          Defaults to ‘Inf’, no limit.

max_trip_duration: An integer. The maximum trip duration in minutes.
          Defaults to 120 minutes (2 hours).

walk_speed: A numeric. Average walk speed in km/h. Defaults to 3.6
          km/h.

bike_speed: A numeric. Average cycling speed in km/h. Defaults to 12
          km/h.

max_rides: An integer. The maximum number of public transport rides
          allowed in the same trip. Defaults to 3.

 max_lts: An integer between 1 and 4. The maximum level of traffic
          stress that cyclists will tolerate. A value of 1 means
          cyclists will only travel through the quietest streets, while
          a value of 4 indicates cyclists can travel through any road.
          Defaults to 2. Please see details for more information.

shortest_path: A logical. Whether the function should only return the
          fastest itinerary between each origin and destination pair
          (the default) or multiple alternatives.

all_to_all: A logical. Whether to query routes between the 1st origin
          to the 1st destination, then the 2nd origin to the 2nd
          destination, and so on (‘FALSE’, the default) or to query
          routes between all origins to all destinations (‘TRUE’).

n_threads: An integer. The number of threads to use when running the
          router in parallel. Defaults to use all available threads
          (Inf).

 verbose: A logical. Whether to show ‘R5’ informative messages when
          running the function. Defaults to ‘FALSE’ (please note that
          in such case ‘R5’ error messages are still shown). Setting
          ‘verbose’ to ‘TRUE’ shows detailed output, which can be
          useful for debugging issues not caught by ‘r5r’.

progress: A logical. Whether to show a progress counter when running
          the router. Defaults to ‘FALSE’. Only works when ‘verbose’ is
          set to ‘FALSE’, so the progress counter does not interfere
          with ‘R5’'s output messages. Setting ‘progress’ to ‘TRUE’ may
          impose a small penalty for computation efficiency, because
          the progress counter must be synchronized among all active
          threads.

drop_geometry: A logical. Whether the output should include the
          geometry of each trip leg or not. The default value of
          ‘FALSE’ keeps the geometry column in the result.

output_dir: Either ‘NULL’ or a path to an existing directory. When not
          ‘NULL’ (the default), the function will write one ‘.csv’ file
          with the results for each origin in the specified directory.
          In such case, the function returns the path specified in this
          parameter. This parameter is particularly useful when running
          on memory-constrained settings because writing the results
          directly to disk prevents ‘r5r’ from loading them to RAM
          memory.

Value:

     When ‘drop_geometry’ is ‘FALSE’, the function outputs a LINESTRING
     sf with detailed information on the itineraries between the
     specified origins and destinations. When ‘TRUE’, the output is a
     ‘data.table’. All distances are in meters and travel times are in
     minutes. If ‘output_dir’ is not ‘NULL’, the function returns the
     path specified in that parameter, in which the ‘.csv’ files
     containing the results are saved.

Transport modes:

     ‘R5’ allows for multiple combinations of transport modes. The
     options include:

        • *Transit modes:* ‘TRAM’, ‘SUBWAY’, ‘RAIL’, ‘BUS’, ‘FERRY’,
          ‘CABLE_CAR’, ‘GONDOLA’, ‘FUNICULAR’. The option ‘TRANSIT’
          automatically considers all public transport modes available.

        • *Non transit modes:* ‘WALK’, ‘BICYCLE’, ‘CAR’,
          ‘BICYCLE_RENT’, ‘CAR_PARK’.

Level of Traffic Stress (LTS):

     When cycling is enabled in ‘R5’ (by passing the value ‘BIKE’ to
     either ‘mode’ or ‘mode_egress’), setting ‘max_lts’ will allow
     cycling only on streets with a given level of danger/stress.
     Setting ‘max_lts’ to 1, for example, will allow cycling only on
     separated bicycle infrastructure or low-traffic streets and
     routing will revert to walking when traversing any links with LTS
     exceeding 1. Setting ‘max_lts’ to 3 will allow cycling on links
     with LTS 1, 2 or 3. Routing also reverts to walking if the street
     segment is tagged as non-bikable in OSM (e.g. a staircase),
     independently of the specified max LTS.

     The default methodology for assigning LTS values to network edges
     is based on commonly tagged attributes of OSM ways. See more info
     about LTS in the original documentation of R5 from Conveyal at
     <https://docs.conveyal.com/learn-more/traffic-stress>. In summary:

        • *LTS 1*: Tolerable for children. This includes low-speed,
          low-volume streets, as well as those with separated bicycle
          facilities (such as parking-protected lanes or cycle tracks).

        • *LTS 2*: Tolerable for the mainstream adult population. This
          includes streets where cyclists have dedicated lanes and only
          have to interact with traffic at formal crossing.

        • *LTS 3*: Tolerable for "enthused and confident" cyclists.
          This includes streets which may involve close proximity to
          moderate- or high-speed vehicular traffic.

        • *LTS 4*: Tolerable only for "strong and fearless" cyclists.
          This includes streets where cyclists are required to mix with
          moderate- to high-speed vehicular traffic.

     For advanced users, you can provide custom LTS values by adding a
     tag <key = "lts"> to the ‘osm.pbf’ file.

Datetime parsing:

     ‘r5r’ ignores the timezone attribute of datetime objects when
     parsing dates and times, using the study area's timezone instead.
     For example, let's say you are running some calculations using Rio
     de Janeiro, Brazil, as your study area. The datetime
     ‘as.POSIXct("13-05-2019 14:00:00", format = "%d-%m-%Y %H:%M:%S")’
     will be parsed as May 13th, 2019, 14:00h in Rio's local time, as
     expected. But ‘as.POSIXct("13-05-2019 14:00:00", format =
     "%d-%m-%Y %H:%M:%S", tz = "Europe/Paris")’ will also be parsed as
     the exact same date and time in Rio's local time, perhaps
     surprisingly, ignoring the timezone attribute.

Routing algorithm:

     The ‘detailed_itineraries()’ and ‘pareto_frontier()’ functions use
     an ‘R5’-specific extension to the McRAPTOR routing algorithm. The
     implementation used in ‘detailed_itineraries()’ allows the router
     to find paths that are optimal and less than optimal in terms of
     travel time, with some heuristics around multiple access modes,
     riding the same patterns, etc. The specific extension to McRAPTOR
     to do suboptimal path routing is not documented yet, but a
     detailed description of base McRAPTOR can be found in Delling et
     al (2015). The implementation used in ‘pareto_frontier()’, on the
     other hand, returns only the fastest trip within a given monetary
     cutoff, ignoring slower trips that cost the same. A detailed
     discussion on the algorithm can be found in Conway and Stewart
     (2019).

        • Delling, D., Pajor, T., & Werneck, R. F. (2015). Round-based
          public transit routing. Transportation Science, 49(3),
          591-604.
          \Sexpr[results=rd]{tools:::Rd_expr_doi("10.1287/trsc.2014.0534")}

        • Conway, M. W., & Stewart, A. F. (2019). Getting Charlie off
          the MTA: a multiobjective optimization method to account for
          cost constraints in public transit accessibility metrics.
          International Journal of Geographical Information Science,
          33(9), 1759-1787.
          \Sexpr[results=rd]{tools:::Rd_expr_doi("10.1080/13658816.2019.1605075")}

See Also:

     Other routing: ‘expanded_travel_time_matrix()’,
     ‘pareto_frontier()’, ‘travel_time_matrix()’

Examples:

     library(r5r)
     
     # build transport network
     data_path <- system.file("extdata/poa", package = "r5r")
     r5r_core <- setup_r5(data_path)
     
     # load origin/destination points
     points <- read.csv(file.path(data_path, "poa_points_of_interest.csv"))
     
     # inputs
     departure_datetime <- as.POSIXct(
       "13-05-2019 14:00:00",
       format = "%d-%m-%Y %H:%M:%S"
     )
     
     det <- detailed_itineraries(
       r5r_core,
       origins = points[10,],
       destinations = points[12,],
       mode = c("WALK", "TRANSIT"),
       departure_datetime = departure_datetime,
       max_trip_duration = 60
     )
     head(det)
     
     stop_r5(r5r_core)
     

--------------------------------------------------------------------------------
Function: download_r5()
Download 'R5.jar'

Description:

     Downloads ‘R5.jar’ and saves it locally, inside the package
     directory.

Usage:

     download_r5(
       version = NULL,
       quiet = FALSE,
       force_update = FALSE,
       temp_dir = FALSE
     )
     
Arguments:

 version: A string. The version of R5 to be downloaded. When ‘NULL’, it
          defaults to the latest version.

   quiet: A logical. Whether to show informative messages when
          downloading the file. Defaults to ‘FALSE’.

force_update: A logical. Whether to overwrite a previously downloaded
          ‘R5.jar’ in the local directory. Defaults to ‘FALSE’.

temp_dir: A logical. Whether the file should be saved in a temporary
          directory. Defaults to ‘FALSE’.

Value:

     The path to the downloaded file.

See Also:

     Other setup: ‘setup_r5()’

Examples:

     library(r5r)
     
     download_r5(temp_dir = TRUE)
     

--------------------------------------------------------------------------------
Function: expand_od_pairs()
Expand origin-destination pairs

Description:

     This function is used in ‘detailed_itineraries()’ to update the
     ‘origins’ and ‘destinations’ datasets.

Usage:

     expand_od_pairs(origins, destinations, all_to_all)
     
Arguments:

 origins: Passed by ‘detailed_itineraries()’.

destinations: Passed by ‘detailed_itineraries()’.

all_to_all: Passed by ‘detailed_itineraries()’.


--------------------------------------------------------------------------------
Function: expanded_travel_time_matrix()
Calculate minute-by-minute travel times between origin destination
pairs

Description:

     Detailed computation of travel time estimates between one or
     multiple origin destination pairs. Results show the travel time of
     the fastest route alternative departing each minute within a
     specified time window. Please note this function can be very
     memory intensive for large data sets and time windows.

Usage:

     expanded_travel_time_matrix(
       r5r_core,
       origins,
       destinations,
       mode = "WALK",
       mode_egress = "WALK",
       departure_datetime = Sys.time(),
       time_window = 10L,
       breakdown = FALSE,
       max_walk_time = Inf,
       max_bike_time = Inf,
       max_car_time = Inf,
       max_trip_duration = 120L,
       walk_speed = 3.6,
       bike_speed = 12,
       max_rides = 3,
       max_lts = 2,
       draws_per_minute = 5L,
       n_threads = Inf,
       verbose = FALSE,
       progress = FALSE,
       output_dir = NULL
     )
     
Arguments:

r5r_core: An object to connect with the R5 routing engine, created with
          ‘setup_r5()’.

origins, destinations: Either a POINT sf object with WGS84 CRS, or a
          ‘data.frame’ containing the columns ‘id’, ‘lon’ and ‘lat’.

    mode: A character vector. The transport modes allowed for access,
          transfer and vehicle legs of the trips. Defaults to ‘WALK’.
          Please see details for other options.

mode_egress: A character vector. The transport mode used after egress
          from the last public transport. It can be either ‘WALK’,
          ‘BICYCLE’ or ‘CAR’. Defaults to ‘WALK’. Ignored when public
          transport is not used.

departure_datetime: A POSIXct object. Please note that the departure
          time only influences public transport legs. When working with
          public transport networks, please check the ‘calendar.txt’
          within your GTFS feeds for valid dates. Please see details
          for further information on how datetimes are parsed.

time_window: An integer. The time window in minutes for which ‘r5r’
          will calculate multiple travel time matrices departing each
          minute. Defaults to 10 minutes. The function returns the
          result based on median travel times. Please read the time
          window vignette for more details on its usage
          ‘vignette("time_window", package = "r5r")’

breakdown: A logical. Whether to include detailed information about
          each trip in the output. If ‘FALSE’ (the default), the output
          lists the total time between each origin-destination pair and
          the routes used to complete the trip for each minute of the
          specified time window. If ‘TRUE’, the output includes the
          total access, waiting, in-vehicle and transfer time of each
          trip. Please note that setting this parameter to ‘TRUE’ makes
          the function significantly slower.

max_walk_time: An integer. The maximum walking time (in minutes) to
          access and egress the transit network, to make transfers
          within the network or to complete walk-only trips. Defaults
          to no restrictions (numeric value of ‘Inf’), as long as
          ‘max_trip_duration’ is respected. When routing transit trips,
          the max time is considered separately for each leg (e.g. if
          you set ‘max_walk_time’ to 15, you could get trips with an up
          to 15 minutes walk leg to reach transit and another up to 15
          minutes walk leg to reach the destination after leaving
          transit. In walk-only trips, whenever ‘max_walk_time’ differs
          from ‘max_trip_duration’, the lowest value is considered.

max_bike_time: An integer. The maximum cycling time (in minutes) to
          access and egress the transit network, to make transfers
          within the network or to complete bicycle-only trips.
          Defaults to no restrictions (numeric value of ‘Inf’), as long
          as ‘max_trip_duration’ is respected. When routing transit
          trips, the max time is considered separately for each leg
          (e.g. if you set ‘max_bike_time’ to 15, you could get trips
          with an up to 15 minutes cycle leg to reach transit and
          another up to 15 minutes cycle leg to reach the destination
          after leaving transit. In bicycle-only trips, whenever
          ‘max_bike_time’ differs from ‘max_trip_duration’, the lowest
          value is considered.

max_car_time: An integer. The maximum driving time (in minutes) to
          access and egress the transit network. Defaults to no
          restrictions, as long as ‘max_trip_duration’ is respected.
          The max time is considered separately for each leg (e.g. if
          you set ‘max_car_time’ to 15 minutes, you could potentially
          drive up to 15 minutes to reach transit, and up to _another_
          15 minutes to reach the destination after leaving transit).
          Defaults to ‘Inf’, no limit.

max_trip_duration: An integer. The maximum trip duration in minutes.
          Defaults to 120 minutes (2 hours).

walk_speed: A numeric. Average walk speed in km/h. Defaults to 3.6
          km/h.

bike_speed: A numeric. Average cycling speed in km/h. Defaults to 12
          km/h.

max_rides: An integer. The maximum number of public transport rides
          allowed in the same trip. Defaults to 3.

 max_lts: An integer between 1 and 4. The maximum level of traffic
          stress that cyclists will tolerate. A value of 1 means
          cyclists will only travel through the quietest streets, while
          a value of 4 indicates cyclists can travel through any road.
          Defaults to 2. Please see details for more information.

draws_per_minute: An integer. The number of Monte Carlo draws to
          perform per time window minute when calculating travel time
          matrices and when estimating accessibility. Defaults to 5.
          This would mean 300 draws in a 60-minute time window, for
          example. This parameter only affects the results when the
          GTFS feeds contain a ‘frequencies.txt’ table. If the GTFS
          feed does not have a frequency table, r5r still allows for
          multiple runs over the set ‘time_window’ but in a
          deterministic way.

n_threads: An integer. The number of threads to use when running the
          router in parallel. Defaults to use all available threads
          (Inf).

 verbose: A logical. Whether to show ‘R5’ informative messages when
          running the function. Defaults to ‘FALSE’ (please note that
          in such case ‘R5’ error messages are still shown). Setting
          ‘verbose’ to ‘TRUE’ shows detailed output, which can be
          useful for debugging issues not caught by ‘r5r’.

progress: A logical. Whether to show a progress counter when running
          the router. Defaults to ‘FALSE’. Only works when ‘verbose’ is
          set to ‘FALSE’, so the progress counter does not interfere
          with ‘R5’'s output messages. Setting ‘progress’ to ‘TRUE’ may
          impose a small penalty for computation efficiency, because
          the progress counter must be synchronized among all active
          threads.

output_dir: Either ‘NULL’ or a path to an existing directory. When not
          ‘NULL’ (the default), the function will write one ‘.csv’ file
          with the results for each origin in the specified directory.
          In such case, the function returns the path specified in this
          parameter. This parameter is particularly useful when running
          on memory-constrained settings because writing the results
          directly to disk prevents ‘r5r’ from loading them to RAM
          memory.

Value:

     A ‘data.table’ with travel time estimates (in minutes) and the
     routes used in each trip between origin and destination pairs, for
     each minute of the specified time window. Each set of origin,
     destination and departure minute can appear up to N times, where N
     is the number of Monte Carlo draws specified in the function
     arguments (please note that this only applies when the GTFS feeds
     that describe the transit network include a frequencies table,
     otherwise only a single draw is performed). A pair is completely
     absent from the final output if no trips could be completed in any
     of the minutes of the time window. If for a single pair trips
     could be completed in some of the minutes of the time window, but
     not for all of them, the minutes in which trips couldn't be
     completed will have ‘NA’ travel time and routes used. If
     ‘output_dir’ is not ‘NULL’, the function returns the path
     specified in that parameter, in which the ‘.csv’ files containing
     the results are saved.

Transport modes:

     ‘R5’ allows for multiple combinations of transport modes. The
     options include:

        • *Transit modes:* ‘TRAM’, ‘SUBWAY’, ‘RAIL’, ‘BUS’, ‘FERRY’,
          ‘CABLE_CAR’, ‘GONDOLA’, ‘FUNICULAR’. The option ‘TRANSIT’
          automatically considers all public transport modes available.

        • *Non transit modes:* ‘WALK’, ‘BICYCLE’, ‘CAR’,
          ‘BICYCLE_RENT’, ‘CAR_PARK’.

Level of Traffic Stress (LTS):

     When cycling is enabled in ‘R5’ (by passing the value ‘BIKE’ to
     either ‘mode’ or ‘mode_egress’), setting ‘max_lts’ will allow
     cycling only on streets with a given level of danger/stress.
     Setting ‘max_lts’ to 1, for example, will allow cycling only on
     separated bicycle infrastructure or low-traffic streets and
     routing will revert to walking when traversing any links with LTS
     exceeding 1. Setting ‘max_lts’ to 3 will allow cycling on links
     with LTS 1, 2 or 3. Routing also reverts to walking if the street
     segment is tagged as non-bikable in OSM (e.g. a staircase),
     independently of the specified max LTS.

     The default methodology for assigning LTS values to network edges
     is based on commonly tagged attributes of OSM ways. See more info
     about LTS in the original documentation of R5 from Conveyal at
     <https://docs.conveyal.com/learn-more/traffic-stress>. In summary:

        • *LTS 1*: Tolerable for children. This includes low-speed,
          low-volume streets, as well as those with separated bicycle
          facilities (such as parking-protected lanes or cycle tracks).

        • *LTS 2*: Tolerable for the mainstream adult population. This
          includes streets where cyclists have dedicated lanes and only
          have to interact with traffic at formal crossing.

        • *LTS 3*: Tolerable for "enthused and confident" cyclists.
          This includes streets which may involve close proximity to
          moderate- or high-speed vehicular traffic.

        • *LTS 4*: Tolerable only for "strong and fearless" cyclists.
          This includes streets where cyclists are required to mix with
          moderate- to high-speed vehicular traffic.

     For advanced users, you can provide custom LTS values by adding a
     tag <key = "lts"> to the ‘osm.pbf’ file.

Datetime parsing:

     ‘r5r’ ignores the timezone attribute of datetime objects when
     parsing dates and times, using the study area's timezone instead.
     For example, let's say you are running some calculations using Rio
     de Janeiro, Brazil, as your study area. The datetime
     ‘as.POSIXct("13-05-2019 14:00:00", format = "%d-%m-%Y %H:%M:%S")’
     will be parsed as May 13th, 2019, 14:00h in Rio's local time, as
     expected. But ‘as.POSIXct("13-05-2019 14:00:00", format =
     "%d-%m-%Y %H:%M:%S", tz = "Europe/Paris")’ will also be parsed as
     the exact same date and time in Rio's local time, perhaps
     surprisingly, ignoring the timezone attribute.

Routing algorithm:

     The ‘travel_time_matrix()’, ‘expanded_travel_time_matrix()’ and
     ‘accessibility()’ functions use an ‘R5’-specific extension to the
     RAPTOR routing algorithm (see Conway et al., 2017). This RAPTOR
     extension uses a systematic sample of one departure per minute
     over the time window set by the user in the 'time_window'
     parameter. A detailed description of base RAPTOR can be found in
     Delling et al (2015). However, whenever the user includes transit
     fares inputs to these functions, they automatically switch to use
     an ‘R5’-specific extension to the McRAPTOR routing algorithm.

        • Conway, M. W., Byrd, A., & van der Linden, M. (2017).
          Evidence-based transit and land use sketch planning using
          interactive accessibility methods on combined schedule and
          headway-based networks. Transportation Research Record,
          2653(1), 45-53.
          \Sexpr[results=rd]{tools:::Rd_expr_doi("10.3141/2653-06")}

        • Delling, D., Pajor, T., & Werneck, R. F. (2015). Round-based
          public transit routing. Transportation Science, 49(3),
          591-604.
          \Sexpr[results=rd]{tools:::Rd_expr_doi("10.1287/trsc.2014.0534")}

See Also:

     Other routing: ‘detailed_itineraries()’, ‘pareto_frontier()’,
     ‘travel_time_matrix()’

Examples:

     library(r5r)
     
     # build transport network
     data_path <- system.file("extdata/poa", package = "r5r")
     r5r_core <- setup_r5(data_path)
     
     # load origin/destination points
     points <- read.csv(file.path(data_path, "poa_points_of_interest.csv"))
     
     departure_datetime <- as.POSIXct(
       "13-05-2019 14:00:00",
       format = "%d-%m-%Y %H:%M:%S"
     )
     
     # by default only returns the total time between each pair in each minute of
     # the specified time window
     ettm <- expanded_travel_time_matrix(
       r5r_core,
       origins = points,
       destinations = points,
       mode = c("WALK", "TRANSIT"),
       time_window = 20,
       departure_datetime = departure_datetime,
       max_trip_duration = 60
     )
     head(ettm)
     
     # when breakdown = TRUE the output contains much more information
     ettm <- expanded_travel_time_matrix(
       r5r_core,
       origins = points,
       destinations = points,
       mode = c("WALK", "TRANSIT"),
       time_window = 20,
       departure_datetime = departure_datetime,
       max_trip_duration = 60,
       breakdown = TRUE
     )
     head(ettm)
     
     stop_r5(r5r_core)
     

--------------------------------------------------------------------------------
Function: fileurl_from_metadata()
Get most recent JAR file url from metadata

Description:

     Returns the most recent JAR file url from metadata, depending on
     the version.

Usage:

     fileurl_from_metadata(version = NULL)
     
Arguments:

 version: A string. The version of R5 to be downloaded. When ‘NULL’, it
          defaults to the latest version.

Value:

     A url a string.

See Also:

     Other support functions: ‘stop_r5()’


--------------------------------------------------------------------------------
Function: find_snap()
Find snapped locations of input points on street network

Description:

     Finds the snapped location of points on ‘R5’ network. Snapping is
     a very important step of the routing process, which is when the
     origins and destinations specified by the user are actually
     positioned on the network created by ‘R5’. The snapping process in
     ‘R5’ is composed of two rounds. First, it tries to snap the points
     within a radius of 300 meters from themselves. If the first round
     is unsuccessful, then ‘R5’ expands the search radius to 1.6 km. If
     yet again it is unsuccessful, then the unsnapped points won't be
     used during the routing process. The snapped location of each
     point depends on the transport mode set by the user, because some
     network edges are not available to specific modes (e.g. a
     pedestrian-only street cannot be used to snap car trips).

Usage:

     find_snap(r5r_core, points, mode = "WALK")
     
Arguments:

r5r_core: An object to connect with the R5 routing engine, created with
          ‘setup_r5()’.

  points: Either a POINT sf object with WGS84 CRS, or a ‘data.frame’
          containing the columns ‘id’, ‘lon’ and ‘lat’.

    mode: A string. Which mode to consider when trying to snap the
          points to the network. Defaults to ‘WALK’, also allows
          ‘BICYCLE’ and ‘CAR’.

Value:

     A ‘data.table’ with the original points, their respective snapped
     coordinates on the street network and the Euclidean distance ( in
     meters) between the original points and their snapped location.
     Points that could not be snapped show ‘NA’ coordinates and ‘found
     = FALSE’.

See Also:

     Other network functions: ‘street_network_to_sf()’,
     ‘transit_network_to_sf()’

Examples:

     library(r5r)
     
     path <- system.file("extdata/poa", package = "r5r")
     r5r_core <- setup_r5(data_path = path)
     points <- read.csv(file.path(path, "poa_hexgrid.csv"))
     
     snap_df <- find_snap(r5r_core, points, mode = "WALK")
     
     stop_r5(r5r_core)
     

--------------------------------------------------------------------------------
Function: isochrone()
Estimate isochrones from a given location

Description:

     Fast computation of isochrones from a given location. The function
     can return either polygon-based or line-based isochrones.
     Polygon-based isochrones are generated as concave polygons based
     on the travel times from the trip origin to all nodes in the
     transport network. Meanwhile, line-based isochronesare based on
     travel times from each origin to the centroids of all segments in
     the transport network.

Usage:

     isochrone(
       r5r_core,
       origins,
       mode = "transit",
       mode_egress = "walk",
       cutoffs = c(0, 15, 30),
       sample_size = 0.8,
       departure_datetime = Sys.time(),
       polygon_output = TRUE,
       time_window = 10L,
       max_walk_time = Inf,
       max_bike_time = Inf,
       max_car_time = Inf,
       max_trip_duration = 120L,
       walk_speed = 3.6,
       bike_speed = 12,
       max_rides = 3,
       max_lts = 2,
       draws_per_minute = 5L,
       n_threads = Inf,
       verbose = FALSE,
       progress = TRUE
     )
     
Arguments:

r5r_core: An object to connect with the R5 routing engine, created with
          ‘setup_r5()’.

 origins: Either a POINT sf object with WGS84 CRS, or a ‘data.frame’
          containing the columns ‘id’, ‘lon’ and ‘lat’.

    mode: A character vector. The transport modes allowed for access,
          transfer and vehicle legs of the trips. Defaults to ‘WALK’.
          Please see details for other options.

mode_egress: A character vector. The transport mode used after egress
          from the last public transport. It can be either ‘WALK’,
          ‘BICYCLE’ or ‘CAR’. Defaults to ‘WALK’. Ignored when public
          transport is not used.

 cutoffs: numeric vector. Number of minutes to define the time span of
          each Isochrone. Defaults to ‘c(0, 15, 30)’.

sample_size: numeric. Sample size of nodes in the transport network
          used to estimate isochrones. Defaults to ‘0.8’ (80% of all
          nodes in the transport network). Value can range between
          ‘0.2’ and ‘1’. Smaller values increase computation speed but
          return results with lower precision. This parameter has no
          effect when ‘polygon_output = FALSE’.

departure_datetime: A POSIXct object. Please note that the departure
          time only influences public transport legs. When working with
          public transport networks, please check the ‘calendar.txt’
          within your GTFS feeds for valid dates. Please see details
          for further information on how datetimes are parsed.

polygon_output: A Logical. If ‘TRUE’, the function outputs
          polygon-based isochrones (the default) based on travel times
          from each origin to a sample of a random sample nodes in the
          transport network (see parameter ‘sample_size’). If ‘FALSE’,
          the function outputs line-based isochrones based on travel
          times from each origin to the centroids of all segments in
          the transport network.

time_window: An integer. The time window in minutes for which ‘r5r’
          will calculate multiple travel time matrices departing each
          minute. Defaults to 10 minutes. The function returns the
          result based on median travel times. Please read the time
          window vignette for more details on its usage
          ‘vignette("time_window", package = "r5r")’

max_walk_time: An integer. The maximum walking time (in minutes) to
          access and egress the transit network, or to make transfers
          within the network. Defaults to no restrictions, as long as
          ‘max_trip_duration’ is respected. The max time is considered
          separately for each leg (e.g. if you set ‘max_walk_time’ to
          15, you could potentially walk up to 15 minutes to reach
          transit, and up to _another_ 15 minutes to reach the
          destination after leaving transit). Defaults to ‘Inf’, no
          limit.

max_bike_time: An integer. The maximum cycling time (in minutes) to
          access and egress the transit network. Defaults to no
          restrictions, as long as ‘max_trip_duration’ is respected.
          The max time is considered separately for each leg (e.g. if
          you set ‘max_bike_time’ to 15 minutes, you could potentially
          cycle up to 15 minutes to reach transit, and up to _another_
          15 minutes to reach the destination after leaving transit).
          Defaults to ‘Inf’, no limit.

max_car_time: An integer. The maximum driving time (in minutes) to
          access and egress the transit network. Defaults to no
          restrictions, as long as ‘max_trip_duration’ is respected.
          The max time is considered separately for each leg (e.g. if
          you set ‘max_car_time’ to 15 minutes, you could potentially
          drive up to 15 minutes to reach transit, and up to _another_
          15 minutes to reach the destination after leaving transit).
          Defaults to ‘Inf’, no limit.

max_trip_duration: An integer. The maximum trip duration in minutes.
          Defaults to 120 minutes (2 hours).

walk_speed: A numeric. Average walk speed in km/h. Defaults to 3.6
          km/h.

bike_speed: A numeric. Average cycling speed in km/h. Defaults to 12
          km/h.

max_rides: An integer. The maximum number of public transport rides
          allowed in the same trip. Defaults to 3.

 max_lts: An integer between 1 and 4. The maximum level of traffic
          stress that cyclists will tolerate. A value of 1 means
          cyclists will only travel through the quietest streets, while
          a value of 4 indicates cyclists can travel through any road.
          Defaults to 2. Please see details for more information.

draws_per_minute: An integer. The number of Monte Carlo draws to
          perform per time window minute when calculating travel time
          matrices and when estimating accessibility. Defaults to 5.
          This would mean 300 draws in a 60-minute time window, for
          example. This parameter only affects the results when the
          GTFS feeds contain a ‘frequencies.txt’ table. If the GTFS
          feed does not have a frequency table, r5r still allows for
          multiple runs over the set ‘time_window’ but in a
          deterministic way.

n_threads: An integer. The number of threads to use when running the
          router in parallel. Defaults to use all available threads
          (‘Inf’).

 verbose: A logical. Whether to show ‘R5’ informative messages when
          running the function. Defaults to ‘FALSE’ (please note that
          in such case ‘R5’ error messages are still shown). Setting
          ‘verbose’ to ‘TRUE’ shows detailed output, which can be
          useful for debugging issues not caught by ‘r5r’.

progress: A logical. Whether to show a progress counter when running
          the router. Defaults to ‘FALSE’. Only works when ‘verbose’ is
          set to ‘FALSE’, so the progress counter does not interfere
          with ‘R5’'s output messages. Setting ‘progress’ to ‘TRUE’ may
          impose a small penalty for computation efficiency, because
          the progress counter must be synchronized among all active
          threads.

Value:

     A POLYGON "sf" "data.frame" for each isochrone of each origin.

Transport modes:

     ‘R5’ allows for multiple combinations of transport modes. The
     options include:

        • *Transit modes:* ‘TRAM’, ‘SUBWAY’, ‘RAIL’, ‘BUS’, ‘FERRY’,
          ‘CABLE_CAR’, ‘GONDOLA’, ‘FUNICULAR’. The option ‘TRANSIT’
          automatically considers all public transport modes available.

        • *Non transit modes:* ‘WALK’, ‘BICYCLE’, ‘CAR’,
          ‘BICYCLE_RENT’, ‘CAR_PARK’.

Level of Traffic Stress (LTS):

     When cycling is enabled in ‘R5’ (by passing the value ‘BIKE’ to
     either ‘mode’ or ‘mode_egress’), setting ‘max_lts’ will allow
     cycling only on streets with a given level of danger/stress.
     Setting ‘max_lts’ to 1, for example, will allow cycling only on
     separated bicycle infrastructure or low-traffic streets and
     routing will revert to walking when traversing any links with LTS
     exceeding 1. Setting ‘max_lts’ to 3 will allow cycling on links
     with LTS 1, 2 or 3. Routing also reverts to walking if the street
     segment is tagged as non-bikable in OSM (e.g. a staircase),
     independently of the specified max LTS.

     The default methodology for assigning LTS values to network edges
     is based on commonly tagged attributes of OSM ways. See more info
     about LTS in the original documentation of R5 from Conveyal at
     <https://docs.conveyal.com/learn-more/traffic-stress>. In summary:

        • *LTS 1*: Tolerable for children. This includes low-speed,
          low-volume streets, as well as those with separated bicycle
          facilities (such as parking-protected lanes or cycle tracks).

        • *LTS 2*: Tolerable for the mainstream adult population. This
          includes streets where cyclists have dedicated lanes and only
          have to interact with traffic at formal crossing.

        • *LTS 3*: Tolerable for "enthused and confident" cyclists.
          This includes streets which may involve close proximity to
          moderate- or high-speed vehicular traffic.

        • *LTS 4*: Tolerable only for "strong and fearless" cyclists.
          This includes streets where cyclists are required to mix with
          moderate- to high-speed vehicular traffic.

     For advanced users, you can provide custom LTS values by adding a
     tag <key = "lts"> to the ‘osm.pbf’ file.

Datetime parsing:

     ‘r5r’ ignores the timezone attribute of datetime objects when
     parsing dates and times, using the study area's timezone instead.
     For example, let's say you are running some calculations using Rio
     de Janeiro, Brazil, as your study area. The datetime
     ‘as.POSIXct("13-05-2019 14:00:00", format = "%d-%m-%Y %H:%M:%S")’
     will be parsed as May 13th, 2019, 14:00h in Rio's local time, as
     expected. But ‘as.POSIXct("13-05-2019 14:00:00", format =
     "%d-%m-%Y %H:%M:%S", tz = "Europe/Paris")’ will also be parsed as
     the exact same date and time in Rio's local time, perhaps
     surprisingly, ignoring the timezone attribute.

Routing algorithm:

     The ‘travel_time_matrix()’, ‘expanded_travel_time_matrix()’ and
     ‘accessibility()’ functions use an ‘R5’-specific extension to the
     RAPTOR routing algorithm (see Conway et al., 2017). This RAPTOR
     extension uses a systematic sample of one departure per minute
     over the time window set by the user in the 'time_window'
     parameter. A detailed description of base RAPTOR can be found in
     Delling et al (2015). However, whenever the user includes transit
     fares inputs to these functions, they automatically switch to use
     an ‘R5’-specific extension to the McRAPTOR routing algorithm.

        • Conway, M. W., Byrd, A., & van der Linden, M. (2017).
          Evidence-based transit and land use sketch planning using
          interactive accessibility methods on combined schedule and
          headway-based networks. Transportation Research Record,
          2653(1), 45-53.
          \Sexpr[results=rd]{tools:::Rd_expr_doi("10.3141/2653-06")}

        • Delling, D., Pajor, T., & Werneck, R. F. (2015). Round-based
          public transit routing. Transportation Science, 49(3),
          591-604.
          \Sexpr[results=rd]{tools:::Rd_expr_doi("10.1287/trsc.2014.0534")}

Examples:

     options(java.parameters = "-Xmx2G")
     library(r5r)
     library(ggplot2)
     
     # build transport network
     data_path <- system.file("extdata/poa", package = "r5r")
     r5r_core <- setup_r5(data_path = data_path)
     
     # load origin/point of interest
     points <- read.csv(file.path(data_path, "poa_points_of_interest.csv"))
     origin <- points[2,]
     
     departure_datetime <- as.POSIXct(
      "13-05-2019 14:00:00",
      format = "%d-%m-%Y %H:%M:%S"
     )
     
     # estimate polygon-based isochrone from origin
     iso_poly <- isochrone(
       r5r_core,
       origins = origin,
       mode = "walk",
       polygon_output = TRUE,
       departure_datetime = departure_datetime,
       cutoffs = seq(0, 120, 30)
       )
     
     head(iso_poly)
     
     
     # estimate line-based isochrone from origin
     iso_lines <- isochrone(
       r5r_core,
       origins = origin,
       mode = "walk",
       polygon_output = FALSE,
       departure_datetime = departure_datetime,
       cutoffs = seq(0, 100, 25)
       )
     
     head(iso_lines)
     
     
     # plot colors
     colors <- c('#ffe0a5','#ffcb69','#ffa600','#ff7c43','#f95d6a',
                 '#d45087','#a05195','#665191','#2f4b7c','#003f5c')
     
     # polygons
     ggplot() +
       geom_sf(data=iso_poly, aes(fill=factor(isochrone))) +
       scale_fill_manual(values = colors) +
       theme_minimal()
     
     # lines
     ggplot() +
       geom_sf(data=iso_lines, aes(color=factor(isochrone))) +
       scale_color_manual(values = colors) +
       theme_minimal()
     
     stop_r5(r5r_core)
     

--------------------------------------------------------------------------------
Function: java_to_dt()
Java object to data.table

Description:

     Converts a Java object returned by r5r_core to an R data.table

Usage:

     java_to_dt(obj)
     
Arguments:

     obj: A Java Object reference

Value:

     An R data.table


--------------------------------------------------------------------------------
Function: pareto_frontier()
Calculate travel time and monetary cost Pareto frontier

Description:

     Fast computation of travel time and monetary cost Pareto frontier
     between origin and destination pairs.

Usage:

     pareto_frontier(
       r5r_core,
       origins,
       destinations,
       mode = c("WALK", "TRANSIT"),
       mode_egress = "WALK",
       departure_datetime = Sys.time(),
       time_window = 10L,
       percentiles = 50L,
       max_walk_time = Inf,
       max_bike_time = Inf,
       max_car_time = Inf,
       max_trip_duration = 120L,
       fare_structure = NULL,
       fare_cutoffs = -1L,
       walk_speed = 3.6,
       bike_speed = 12,
       max_rides = 3,
       max_lts = 2,
       n_threads = Inf,
       verbose = FALSE,
       progress = FALSE,
       output_dir = NULL
     )
     
Arguments:

r5r_core: An object to connect with the R5 routing engine, created with
          ‘setup_r5()’.

origins, destinations: Either a POINT sf object with WGS84 CRS, or a
          ‘data.frame’ containing the columns ‘id’, ‘lon’ and ‘lat’.

    mode: A character vector. The transport modes allowed for access,
          transfer and vehicle legs of the trips. Defaults to ‘WALK’.
          Please see details for other options.

mode_egress: A character vector. The transport mode used after egress
          from the last public transport. It can be either ‘WALK’,
          ‘BICYCLE’ or ‘CAR’. Defaults to ‘WALK’. Ignored when public
          transport is not used.

departure_datetime: A POSIXct object. Please note that the departure
          time only influences public transport legs. When working with
          public transport networks, please check the ‘calendar.txt’
          within your GTFS feeds for valid dates. Please see details
          for further information on how datetimes are parsed.

time_window: An integer. The time window in minutes for which ‘r5r’
          will calculate multiple travel time matrices departing each
          minute. Defaults to 10 minutes. By default, the function
          returns the result based on median travel times, but the user
          can set the ‘percentiles’ parameter to extract more results.
          Please read the time window vignette for more details on its
          usage ‘vignette("time_window", package = "r5r")’

percentiles: An integer vector (max length of 5). Specifies the
          percentile to use when returning travel time estimates within
          the given time window. Please note that this parameter is
          applied to the travel time estimates only (e.g. if the 25th
          percentile is specified, and the output between A and B is 15
          minutes and 10 dollars, 25% of all trips cheaper than 10
          dollars taken between these points are shorter than 15
          minutes). Defaults to 50, returning the median travel time.
          If a vector with length bigger than 1 is passed, the output
          contains an additional column that specifies the percentile
          of each travel time and monetary cost combination. Due to
          upstream restrictions, only 5 percentiles can be specified at
          a time. For more details, please see R5 documentation at
          <https://docs.conveyal.com/analysis/methodology#accounting-for-variability>.

max_walk_time: An integer. The maximum walking time (in minutes) to
          access and egress the transit network, to make transfers
          within the network or to complete walk-only trips. Defaults
          to no restrictions (numeric value of ‘Inf’), as long as
          ‘max_trip_duration’ is respected. When routing transit trips,
          the max time is considered separately for each leg (e.g. if
          you set ‘max_walk_time’ to 15, you could get trips with an up
          to 15 minutes walk leg to reach transit and another up to 15
          minutes walk leg to reach the destination after leaving
          transit. In walk-only trips, whenever ‘max_walk_time’ differs
          from ‘max_trip_duration’, the lowest value is considered.

max_bike_time: An integer. The maximum cycling time (in minutes) to
          access and egress the transit network, to make transfers
          within the network or to complete bicycle-only trips.
          Defaults to no restrictions (numeric value of ‘Inf’), as long
          as ‘max_trip_duration’ is respected. When routing transit
          trips, the max time is considered separately for each leg
          (e.g. if you set ‘max_bike_time’ to 15, you could get trips
          with an up to 15 minutes cycle leg to reach transit and
          another up to 15 minutes cycle leg to reach the destination
          after leaving transit. In bicycle-only trips, whenever
          ‘max_bike_time’ differs from ‘max_trip_duration’, the lowest
          value is considered.

max_car_time: An integer. The maximum driving time (in minutes) to
          access and egress the transit network. Defaults to no
          restrictions, as long as ‘max_trip_duration’ is respected.
          The max time is considered separately for each leg (e.g. if
          you set ‘max_car_time’ to 15 minutes, you could potentially
          drive up to 15 minutes to reach transit, and up to _another_
          15 minutes to reach the destination after leaving transit).
          Defaults to ‘Inf’, no limit.

max_trip_duration: An integer. The maximum trip duration in minutes.
          Defaults to 120 minutes (2 hours).

fare_structure: A fare structure object, following the convention set
          in ‘setup_fare_structure()’. This object describes how
          transit fares should be calculated. Please see the fare
          structure vignette to understand how this object is
          structured: ‘vignette("fare_structure", package = "r5r")’.

fare_cutoffs: A numeric vector. The monetary cutoffs that should be
          considered when calculating the Pareto frontier. Most of the
          time you'll want this parameter to be the combination of all
          possible fares listed in you ‘fare_structure’. Choosing a
          coarse distribution of cutoffs may result in many different
          trips falling within the same cutoff. For example, if you
          have two different routes in your GTFS, one costing $3 and
          the other costing $4, and you set this parameter to ‘5’, the
          output will tell you the fastest trips that costed up to $5,
          but you won't be able to identify which route was used to
          complete such trips. In this case, it would be more
          beneficial to set the parameter as ‘c(3, 4)’ (you could also
          specify combinations of such values, such as 6, 7, 8 and so
          on, because a transit user could hypothetically benefit from
          making transfers between the available routes).

walk_speed: A numeric. Average walk speed in km/h. Defaults to 3.6
          km/h.

bike_speed: A numeric. Average cycling speed in km/h. Defaults to 12
          km/h.

max_rides: An integer. The maximum number of public transport rides
          allowed in the same trip. Defaults to 3.

 max_lts: An integer between 1 and 4. The maximum level of traffic
          stress that cyclists will tolerate. A value of 1 means
          cyclists will only travel through the quietest streets, while
          a value of 4 indicates cyclists can travel through any road.
          Defaults to 2. Please see details for more information.

n_threads: An integer. The number of threads to use when running the
          router in parallel. Defaults to use all available threads
          (Inf).

 verbose: A logical. Whether to show ‘R5’ informative messages when
          running the function. Defaults to ‘FALSE’ (please note that
          in such case ‘R5’ error messages are still shown). Setting
          ‘verbose’ to ‘TRUE’ shows detailed output, which can be
          useful for debugging issues not caught by ‘r5r’.

progress: A logical. Whether to show a progress counter when running
          the router. Defaults to ‘FALSE’. Only works when ‘verbose’ is
          set to ‘FALSE’, so the progress counter does not interfere
          with ‘R5’'s output messages. Setting ‘progress’ to ‘TRUE’ may
          impose a small penalty for computation efficiency, because
          the progress counter must be synchronized among all active
          threads.

output_dir: Either ‘NULL’ or a path to an existing directory. When not
          ‘NULL’ (the default), the function will write one ‘.csv’ file
          with the results for each origin in the specified directory.
          In such case, the function returns the path specified in this
          parameter. This parameter is particularly useful when running
          on memory-constrained settings because writing the results
          directly to disk prevents ‘r5r’ from loading them to RAM
          memory.

Value:

     A ‘data.table’ with the travel time and monetary cost Pareto
     frontier between the specified origins and destinations. An
     additional column identifying the travel time percentile is
     present if more than one value was passed to ‘percentiles’. Origin
     and destination pairs whose trips couldn't be completed within the
     maximum travel time using less money than the specified monetary
     cutoffs are not returned in the ‘data.table’. If ‘output_dir’ is
     not ‘NULL’, the function returns the path specified in that
     parameter, in which the ‘.csv’ files containing the results are
     saved.

Transport modes:

     ‘R5’ allows for multiple combinations of transport modes. The
     options include:

        • *Transit modes:* ‘TRAM’, ‘SUBWAY’, ‘RAIL’, ‘BUS’, ‘FERRY’,
          ‘CABLE_CAR’, ‘GONDOLA’, ‘FUNICULAR’. The option ‘TRANSIT’
          automatically considers all public transport modes available.

        • *Non transit modes:* ‘WALK’, ‘BICYCLE’, ‘CAR’,
          ‘BICYCLE_RENT’, ‘CAR_PARK’.

Level of Traffic Stress (LTS):

     When cycling is enabled in ‘R5’ (by passing the value ‘BIKE’ to
     either ‘mode’ or ‘mode_egress’), setting ‘max_lts’ will allow
     cycling only on streets with a given level of danger/stress.
     Setting ‘max_lts’ to 1, for example, will allow cycling only on
     separated bicycle infrastructure or low-traffic streets and
     routing will revert to walking when traversing any links with LTS
     exceeding 1. Setting ‘max_lts’ to 3 will allow cycling on links
     with LTS 1, 2 or 3. Routing also reverts to walking if the street
     segment is tagged as non-bikable in OSM (e.g. a staircase),
     independently of the specified max LTS.

     The default methodology for assigning LTS values to network edges
     is based on commonly tagged attributes of OSM ways. See more info
     about LTS in the original documentation of R5 from Conveyal at
     <https://docs.conveyal.com/learn-more/traffic-stress>. In summary:

        • *LTS 1*: Tolerable for children. This includes low-speed,
          low-volume streets, as well as those with separated bicycle
          facilities (such as parking-protected lanes or cycle tracks).

        • *LTS 2*: Tolerable for the mainstream adult population. This
          includes streets where cyclists have dedicated lanes and only
          have to interact with traffic at formal crossing.

        • *LTS 3*: Tolerable for "enthused and confident" cyclists.
          This includes streets which may involve close proximity to
          moderate- or high-speed vehicular traffic.

        • *LTS 4*: Tolerable only for "strong and fearless" cyclists.
          This includes streets where cyclists are required to mix with
          moderate- to high-speed vehicular traffic.

     For advanced users, you can provide custom LTS values by adding a
     tag <key = "lts"> to the ‘osm.pbf’ file.

Datetime parsing:

     ‘r5r’ ignores the timezone attribute of datetime objects when
     parsing dates and times, using the study area's timezone instead.
     For example, let's say you are running some calculations using Rio
     de Janeiro, Brazil, as your study area. The datetime
     ‘as.POSIXct("13-05-2019 14:00:00", format = "%d-%m-%Y %H:%M:%S")’
     will be parsed as May 13th, 2019, 14:00h in Rio's local time, as
     expected. But ‘as.POSIXct("13-05-2019 14:00:00", format =
     "%d-%m-%Y %H:%M:%S", tz = "Europe/Paris")’ will also be parsed as
     the exact same date and time in Rio's local time, perhaps
     surprisingly, ignoring the timezone attribute.

Routing algorithm:

     The ‘detailed_itineraries()’ and ‘pareto_frontier()’ functions use
     an ‘R5’-specific extension to the McRAPTOR routing algorithm. The
     implementation used in ‘detailed_itineraries()’ allows the router
     to find paths that are optimal and less than optimal in terms of
     travel time, with some heuristics around multiple access modes,
     riding the same patterns, etc. The specific extension to McRAPTOR
     to do suboptimal path routing is not documented yet, but a
     detailed description of base McRAPTOR can be found in Delling et
     al (2015). The implementation used in ‘pareto_frontier()’, on the
     other hand, returns only the fastest trip within a given monetary
     cutoff, ignoring slower trips that cost the same. A detailed
     discussion on the algorithm can be found in Conway and Stewart
     (2019).

        • Delling, D., Pajor, T., & Werneck, R. F. (2015). Round-based
          public transit routing. Transportation Science, 49(3),
          591-604.
          \Sexpr[results=rd]{tools:::Rd_expr_doi("10.1287/trsc.2014.0534")}

        • Conway, M. W., & Stewart, A. F. (2019). Getting Charlie off
          the MTA: a multiobjective optimization method to account for
          cost constraints in public transit accessibility metrics.
          International Journal of Geographical Information Science,
          33(9), 1759-1787.
          \Sexpr[results=rd]{tools:::Rd_expr_doi("10.1080/13658816.2019.1605075")}

See Also:

     Other routing: ‘detailed_itineraries()’,
     ‘expanded_travel_time_matrix()’, ‘travel_time_matrix()’

Examples:

     library(r5r)
     
     # build transport network
     data_path <- system.file("extdata/poa", package = "r5r")
     r5r_core <- setup_r5(data_path = data_path)
     
     # load origin/destination points
     points <- read.csv(file.path(data_path, "poa_hexgrid.csv"))[1:5,]
     
     # load fare structure object
     fare_structure_path <- system.file(
       "extdata/poa/fares/fares_poa.zip",
       package = "r5r"
     )
     fare_structure <- read_fare_structure(fare_structure_path)
     
     departure_datetime <- as.POSIXct(
       "13-05-2019 14:00:00",
       format = "%d-%m-%Y %H:%M:%S"
     )
     
     pf <- pareto_frontier(
       r5r_core,
       origins = points,
       destinations = points,
       mode = c("WALK", "TRANSIT"),
       departure_datetime = departure_datetime,
       fare_structure = fare_structure,
       fare_cutoffs = c(4.5, 4.8, 9, 9.3, 9.6)
     )
     head(pf)
     
     stop_r5(r5r_core)
     

--------------------------------------------------------------------------------
Function: r5r_cache()
Manage cached files from the r5r package

Description:

     Manage cached files from the r5r package

Usage:

     r5r_cache(list_files = TRUE, delete_file = NULL)
     
Arguments:

list_files: Logical. Whether to print a message with the address of r5r
          JAR files cached locally. Defaults to ‘TRUE’.

delete_file: String. The file name (basename) of a JAR file cached
          locally that should be deleted. Defaults to ‘NULL’, so that
          no file is deleted. If ‘delete_file = "all"’, then all cached
          files are deleted.

Value:

     A message indicating which file exist and/or which ones have been
     deleted from local cache directory.

Examples:

     # download r5 JAR
     r5r::download_r5()
     
     # list all files cached
     r5r_cache(list_files = TRUE)
     
     # delete r5 JAR
     r5r_cache(delete_file = 'r5-v7.0')
     

--------------------------------------------------------------------------------
Function: r5r_sitrep()
Generate an r5r situation report to help debug errors

Description:

     The function reports a list with the following information:

        • The package version of ‘{r5r}’ in use.

        • The installed version of ‘R5.jar’.

        • The Java version in use.

        • The amount of memory set to Java through the
          ‘java.parameters’ option.

        • The user's Session Info.

Usage:

     r5r_sitrep()
     
Value:

     A ‘list’ with information of the versions of the r5r package, Java
     and R5 Jar in use, the memory set to Java and user's Session Info.

Examples:

     r5r_sitrep()
     

--------------------------------------------------------------------------------
Function: r5r()
r5r: Rapid Realistic Routing with 'R5'

Description:

     Rapid realistic routing on multimodal transport networks (walk,
     bike, public transport and car) using ‘R5’, the Rapid Realistic
     Routing on Real-world and Reimagined networks engine
     <https://github.com/conveyal/r5>. The package allows users to
     generate detailed routing analysis or calculate travel time
     matrices using seamless parallel computing on top of the R5 Java
     machine. While ‘R5’ is developed by Conveyal, the package ‘r5r’ is
     independently developed by a team at the Institute for Applied
     Economic Research (Ipea) with contributions from collaborators.
     Apart from the documentation in this package, users will find
     additional information on ‘R5’ documentation at
     <https://docs.conveyal.com/>. Although we try to keep new releases
     of ‘r5r’ in synchrony with ‘R5’, the development of ‘R5’ follows
     Conveyal's independent update process. Hence, users should confirm
     if the ‘R5’ version implied by the Conveyal user manual (see
     <https://docs.conveyal.com/changelog>) corresponds with the ‘R5’
     version that ‘r5r’ depends on.

Usage:

     Please check the vignettes on the website.

Author(s):

     *Maintainer*: Rafael H. M. Pereira
     <mailto:rafa.pereira.br@gmail.com> (ORCID)

     Authors:

        • Marcus Saraiva <mailto:marcus.saraiva@gmail.com> (ORCID)

        • Daniel Herszenhut <mailto:dhersz@gmail.com> (ORCID)

        • Carlos Kaue Vieira Braga <mailto:kaue@kauebraga.dev> (ORCID)

        • Matthew Wigginton Bhagat-Conway <mailto:mwbc@unc.edu> (ORCID)

     Other contributors:

        • Luyu Liu <mailto:luyuliu@ufl.edu> (ORCID) [contributor]

        • Ipea - Institute for Applied Economic Research [copyright
          holder, funder]

See Also:

     Useful links:

        • <https://github.com/ipeaGIT/r5r>

        • <https://ipeagit.github.io/r5r/>

        • Report bugs at <https://github.com/ipeaGIT/r5r/issues>


--------------------------------------------------------------------------------
Function: read_fare_structure()
Read a fare structure object from a file

Description:

     Read a fare structure object from a file

Usage:

     read_fare_structure(file_path, encoding = "UTF-8")
     
Arguments:

file_path: A path pointing to a fare structure with a ‘.zip’ extension.

encoding: A string. Passed to ‘data.table::fread()’, defaults to
          ‘"UTF-8"’. Other possible options are ‘"unknown"’ and
          ‘"Latin-1"’. Please note that this is not used to re-encode
          the input, but to enable handling encoded strings in their
          native encoding.

Value:

     A fare structure object.

See Also:

     Other fare structure: ‘setup_fare_structure()’,
     ‘write_fare_structure()’

Examples:

     path <- system.file("extdata/poa/fares/fares_poa.zip", package = "r5r")
     fare_structure <- read_fare_structure(path)
     

--------------------------------------------------------------------------------
Function: set_breakdown()
Set breakdown

Description:

     Sets whether travel time matrices should include detailed trip
     information or not.

Usage:

     set_breakdown(r5r_core, breakdown)
     
Arguments:

r5r_core: An object to connect with the R5 routing engine, created with
          ‘setup_r5()’.

breakdown: A logical.

Value:

     Invisibly returns ‘TRUE’.

See Also:

     Other setting functions: ‘set_cutoffs()’,
     ‘set_expanded_travel_times()’, ‘set_fare_cutoffs()’,
     ‘set_fare_structure()’, ‘set_max_fare()’, ‘set_max_lts()’,
     ‘set_max_rides()’, ‘set_monte_carlo_draws()’, ‘set_n_threads()’,
     ‘set_output_dir()’, ‘set_percentiles()’, ‘set_progress()’,
     ‘set_speed()’, ‘set_suboptimal_minutes()’, ‘set_time_window()’,
     ‘set_verbose()’


--------------------------------------------------------------------------------
Function: set_cutoffs()
Set cutoffs

Description:

     Sets the cutoffs used when calculating accessibility.

Usage:

     set_cutoffs(r5r_core, cutoffs, decay_function)
     
Arguments:

r5r_core: An object to connect with the R5 routing engine, created with
          ‘setup_r5()’.

 cutoffs: A numeric vector.

decay_function: A string, the name of the decay function.

Value:

     Invisibly returns ‘TRUE’.

See Also:

     Other setting functions: ‘set_breakdown()’,
     ‘set_expanded_travel_times()’, ‘set_fare_cutoffs()’,
     ‘set_fare_structure()’, ‘set_max_fare()’, ‘set_max_lts()’,
     ‘set_max_rides()’, ‘set_monte_carlo_draws()’, ‘set_n_threads()’,
     ‘set_output_dir()’, ‘set_percentiles()’, ‘set_progress()’,
     ‘set_speed()’, ‘set_suboptimal_minutes()’, ‘set_time_window()’,
     ‘set_verbose()’


--------------------------------------------------------------------------------
Function: set_expanded_travel_times()
Set expanded travel times

Description:

     Sets whether travel time matrices should return results for each
     minute of the specified time window.

Usage:

     set_expanded_travel_times(r5r_core, expanded)
     
Arguments:

r5r_core: An object to connect with the R5 routing engine, created with
          ‘setup_r5()’.

expanded: A logical.

Value:

     Invisibly returns ‘TRUE’.

See Also:

     Other setting functions: ‘set_breakdown()’, ‘set_cutoffs()’,
     ‘set_fare_cutoffs()’, ‘set_fare_structure()’, ‘set_max_fare()’,
     ‘set_max_lts()’, ‘set_max_rides()’, ‘set_monte_carlo_draws()’,
     ‘set_n_threads()’, ‘set_output_dir()’, ‘set_percentiles()’,
     ‘set_progress()’, ‘set_speed()’, ‘set_suboptimal_minutes()’,
     ‘set_time_window()’, ‘set_verbose()’


--------------------------------------------------------------------------------
Function: set_fare_cutoffs()
Set monetary cutoffs

Description:

     Sets the monetary cutoffs that should be considered when
     calculating the Pareto frontier.

Usage:

     set_fare_cutoffs(r5r_core, fare_cutoffs)
     
Arguments:

r5r_core: An object to connect with the R5 routing engine, created with
          ‘setup_r5()’.

fare_cutoffs: A path.

Value:

     Invisibly returns ‘TRUE’.

See Also:

     Other setting functions: ‘set_breakdown()’, ‘set_cutoffs()’,
     ‘set_expanded_travel_times()’, ‘set_fare_structure()’,
     ‘set_max_fare()’, ‘set_max_lts()’, ‘set_max_rides()’,
     ‘set_monte_carlo_draws()’, ‘set_n_threads()’, ‘set_output_dir()’,
     ‘set_percentiles()’, ‘set_progress()’, ‘set_speed()’,
     ‘set_suboptimal_minutes()’, ‘set_time_window()’, ‘set_verbose()’


--------------------------------------------------------------------------------
Function: set_fare_structure()
Set the fare structure used when calculating transit fares

Description:

     Sets the fare structure used by our "generic" fare calculator. A
     value of ‘NULL’ is passed to ‘fare_structure’ by the upstream
     routing and accessibility functions when fares are not to be
     calculated.

Usage:

     set_fare_structure(r5r_core, fare_structure)
     
Arguments:

r5r_core: An object to connect with the R5 routing engine, created with
          ‘setup_r5()’.

fare_structure: A fare structure object, following the convention set
          in ‘setup_fare_structure()’. This object describes how
          transit fares should be calculated. Please see the fare
          structure vignette to understand how this object is
          structured: ‘vignette("fare_structure", package = "r5r")’.

Value:

     Invisibly returns ‘TRUE’.

See Also:

     Other setting functions: ‘set_breakdown()’, ‘set_cutoffs()’,
     ‘set_expanded_travel_times()’, ‘set_fare_cutoffs()’,
     ‘set_max_fare()’, ‘set_max_lts()’, ‘set_max_rides()’,
     ‘set_monte_carlo_draws()’, ‘set_n_threads()’, ‘set_output_dir()’,
     ‘set_percentiles()’, ‘set_progress()’, ‘set_speed()’,
     ‘set_suboptimal_minutes()’, ‘set_time_window()’, ‘set_verbose()’


--------------------------------------------------------------------------------
Function: set_max_fare()
Set max fare

Description:

     Sets the max fare allowed when calculating transit fares.

Usage:

     set_max_fare(r5r_core, max_fare)
     
Arguments:

r5r_core: An object to connect with the R5 routing engine, created with
          ‘setup_r5()’.

max_fare: A number.

Value:

     Invisibly returns ‘TRUE’.

See Also:

     Other setting functions: ‘set_breakdown()’, ‘set_cutoffs()’,
     ‘set_expanded_travel_times()’, ‘set_fare_cutoffs()’,
     ‘set_fare_structure()’, ‘set_max_lts()’, ‘set_max_rides()’,
     ‘set_monte_carlo_draws()’, ‘set_n_threads()’, ‘set_output_dir()’,
     ‘set_percentiles()’, ‘set_progress()’, ‘set_speed()’,
     ‘set_suboptimal_minutes()’, ‘set_time_window()’, ‘set_verbose()’


--------------------------------------------------------------------------------
Function: set_max_lts()
Set max Level of Transit Stress (LTS)

Description:

     Set max Level of Transit Stress (LTS)

Usage:

     set_max_lts(r5r_core, max_lts)
     
Arguments:

r5r_core: An object to connect with the R5 routing engine, created with
          ‘setup_r5()’.

 max_lts: A number (between 1 and 4). The maximum level of traffic
          stress that cyclists will tolerate. A value of 1 means
          cyclists will only travel through the quietest streets, while
          a value of 4 indicates cyclists can travel through any road.

Value:

     Invisibly returns ‘TRUE’.

See Also:

     Other setting functions: ‘set_breakdown()’, ‘set_cutoffs()’,
     ‘set_expanded_travel_times()’, ‘set_fare_cutoffs()’,
     ‘set_fare_structure()’, ‘set_max_fare()’, ‘set_max_rides()’,
     ‘set_monte_carlo_draws()’, ‘set_n_threads()’, ‘set_output_dir()’,
     ‘set_percentiles()’, ‘set_progress()’, ‘set_speed()’,
     ‘set_suboptimal_minutes()’, ‘set_time_window()’, ‘set_verbose()’


--------------------------------------------------------------------------------
Function: set_max_rides()
Set max number of rides

Description:

     Sets the maximum number of rides a trip can use in R5.

Usage:

     set_max_rides(r5r_core, max_rides)
     
Arguments:

r5r_core: An object to connect with the R5 routing engine, created with
          ‘setup_r5()’.

max_rides: A number. The max number of public transport rides allowed
          in the same trip. Passed from routing function.

Value:

     No return value, called for side effects.

See Also:

     Other setting functions: ‘set_breakdown()’, ‘set_cutoffs()’,
     ‘set_expanded_travel_times()’, ‘set_fare_cutoffs()’,
     ‘set_fare_structure()’, ‘set_max_fare()’, ‘set_max_lts()’,
     ‘set_monte_carlo_draws()’, ‘set_n_threads()’, ‘set_output_dir()’,
     ‘set_percentiles()’, ‘set_progress()’, ‘set_speed()’,
     ‘set_suboptimal_minutes()’, ‘set_time_window()’, ‘set_verbose()’


--------------------------------------------------------------------------------
Function: set_monte_carlo_draws()
Set number of Monte Carlo draws

Description:

     Sets the number of Monte Carlo draws to be used by R5.

Usage:

     set_monte_carlo_draws(r5r_core, draws_per_minute, time_window)
     
Arguments:

r5r_core: An object to connect with the R5 routing engine, created with
          ‘setup_r5()’.

draws_per_minute: A number.

time_window: A number.

Value:

     Invisibly returns ‘TRUE’.

See Also:

     Other setting functions: ‘set_breakdown()’, ‘set_cutoffs()’,
     ‘set_expanded_travel_times()’, ‘set_fare_cutoffs()’,
     ‘set_fare_structure()’, ‘set_max_fare()’, ‘set_max_lts()’,
     ‘set_max_rides()’, ‘set_n_threads()’, ‘set_output_dir()’,
     ‘set_percentiles()’, ‘set_progress()’, ‘set_speed()’,
     ‘set_suboptimal_minutes()’, ‘set_time_window()’, ‘set_verbose()’


--------------------------------------------------------------------------------
Function: set_n_threads()
Set number of threads

Description:

     Sets the number of threads to be used by the r5r ‘.jar’.

Usage:

     set_n_threads(r5r_core, n_threads)
     
Arguments:

r5r_core: An object to connect with the R5 routing engine, created with
          ‘setup_r5()’.

n_threads: A number, passed from the function above.

Value:

     Invisibly returns ‘TRUE’.

See Also:

     Other setting functions: ‘set_breakdown()’, ‘set_cutoffs()’,
     ‘set_expanded_travel_times()’, ‘set_fare_cutoffs()’,
     ‘set_fare_structure()’, ‘set_max_fare()’, ‘set_max_lts()’,
     ‘set_max_rides()’, ‘set_monte_carlo_draws()’, ‘set_output_dir()’,
     ‘set_percentiles()’, ‘set_progress()’, ‘set_speed()’,
     ‘set_suboptimal_minutes()’, ‘set_time_window()’, ‘set_verbose()’


--------------------------------------------------------------------------------
Function: set_output_dir()
Set output directory

Description:

     Sets whether r5r should save output to a specified directory.

Usage:

     set_output_dir(r5r_core, output_dir)
     
Arguments:

r5r_core: An object to connect with the R5 routing engine, created with
          ‘setup_r5()’.

output_dir: A path.

Value:

     Invisibly returns ‘TRUE’.

See Also:

     Other setting functions: ‘set_breakdown()’, ‘set_cutoffs()’,
     ‘set_expanded_travel_times()’, ‘set_fare_cutoffs()’,
     ‘set_fare_structure()’, ‘set_max_fare()’, ‘set_max_lts()’,
     ‘set_max_rides()’, ‘set_monte_carlo_draws()’, ‘set_n_threads()’,
     ‘set_percentiles()’, ‘set_progress()’, ‘set_speed()’,
     ‘set_suboptimal_minutes()’, ‘set_time_window()’, ‘set_verbose()’


--------------------------------------------------------------------------------
Function: set_percentiles()
Set percentiles

Description:

     Sets the percentiles to be used by R5.

Usage:

     set_percentiles(r5r_core, percentiles)
     
Arguments:

r5r_core: An object to connect with the R5 routing engine, created with
          ‘setup_r5()’.

percentiles: An integer vector of maximum length 5.

Value:

     Invisibly returns ‘TRUE’.

See Also:

     Other setting functions: ‘set_breakdown()’, ‘set_cutoffs()’,
     ‘set_expanded_travel_times()’, ‘set_fare_cutoffs()’,
     ‘set_fare_structure()’, ‘set_max_fare()’, ‘set_max_lts()’,
     ‘set_max_rides()’, ‘set_monte_carlo_draws()’, ‘set_n_threads()’,
     ‘set_output_dir()’, ‘set_progress()’, ‘set_speed()’,
     ‘set_suboptimal_minutes()’, ‘set_time_window()’, ‘set_verbose()’


--------------------------------------------------------------------------------
Function: set_progress()
Set progress argument

Description:

     Indicates whether or not a progress counter must be printed during
     computations. Applies to all routing functions.

Usage:

     set_progress(r5r_core, progress)
     
Arguments:

r5r_core: An object to connect with the R5 routing engine, created with
          ‘setup_r5()’.

progress: A logical, passed from the function above.

Value:

     Invisibly returns ‘TRUE’.

See Also:

     Other setting functions: ‘set_breakdown()’, ‘set_cutoffs()’,
     ‘set_expanded_travel_times()’, ‘set_fare_cutoffs()’,
     ‘set_fare_structure()’, ‘set_max_fare()’, ‘set_max_lts()’,
     ‘set_max_rides()’, ‘set_monte_carlo_draws()’, ‘set_n_threads()’,
     ‘set_output_dir()’, ‘set_percentiles()’, ‘set_speed()’,
     ‘set_suboptimal_minutes()’, ‘set_time_window()’, ‘set_verbose()’


--------------------------------------------------------------------------------
Function: set_speed()
Set walk and bike speed

Description:

     This function receives the walk and bike 'speed' inputs in Km/h
     from routing functions above and converts them to meters per
     second, which is then used to set these speed profiles in r5r JAR.

Usage:

     set_speed(r5r_core, speed, mode)
     
Arguments:

r5r_core: An object to connect with the R5 routing engine, created with
          ‘setup_r5()’.

   speed: A number representing the speed in km/h.

    mode: A string. Either ‘"bike"’ or ‘"walk"’.

Value:

     Invisibly returns ‘TRUE’.

See Also:

     Other setting functions: ‘set_breakdown()’, ‘set_cutoffs()’,
     ‘set_expanded_travel_times()’, ‘set_fare_cutoffs()’,
     ‘set_fare_structure()’, ‘set_max_fare()’, ‘set_max_lts()’,
     ‘set_max_rides()’, ‘set_monte_carlo_draws()’, ‘set_n_threads()’,
     ‘set_output_dir()’, ‘set_percentiles()’, ‘set_progress()’,
     ‘set_suboptimal_minutes()’, ‘set_time_window()’, ‘set_verbose()’


--------------------------------------------------------------------------------
Function: set_suboptimal_minutes()
Set suboptimal minutes

Description:

     Sets the number of suboptimal minutes considered in
     ‘detailed_itineraries()’ routing. From R5 documentation: "This
     parameter compensates for the fact that GTFS does not contain
     information about schedule deviation (lateness). The min-max
     travel time range for some trains is zero, since the trips are
     reported to always have the same timings in the schedule. Such an
     option does not overlap (temporally) its alternatives, and is too
     easily eliminated by an alternative that is only marginally
     better. We want to effectively push the max travel time of
     alternatives out a bit to account for the fact that they don't
     always run on schedule".

Usage:

     set_suboptimal_minutes(
       r5r_core,
       suboptimal_minutes,
       fare_structure,
       shortest_path
     )
     
Arguments:

r5r_core: An object to connect with the R5 routing engine, created with
          ‘setup_r5()’.

suboptimal_minutes: A number.

fare_structure: A fare structure object, following the convention set
          in ‘setup_fare_structure()’. This object describes how
          transit fares should be calculated. Please see the fare
          structure vignette to understand how this object is
          structured: ‘vignette("fare_structure", package = "r5r")’.

shortest_path: A logical.

Value:

     Invisibly returns ‘TRUE’.

See Also:

     Other setting functions: ‘set_breakdown()’, ‘set_cutoffs()’,
     ‘set_expanded_travel_times()’, ‘set_fare_cutoffs()’,
     ‘set_fare_structure()’, ‘set_max_fare()’, ‘set_max_lts()’,
     ‘set_max_rides()’, ‘set_monte_carlo_draws()’, ‘set_n_threads()’,
     ‘set_output_dir()’, ‘set_percentiles()’, ‘set_progress()’,
     ‘set_speed()’, ‘set_time_window()’, ‘set_verbose()’


--------------------------------------------------------------------------------
Function: set_time_window()
Set time window

Description:

     Sets the time window to be used by R5.

Usage:

     set_time_window(r5r_core, time_window)
     
Arguments:

r5r_core: An object to connect with the R5 routing engine, created with
          ‘setup_r5()’.

time_window: A number.

Value:

     Invisibly returns ‘TRUE’.

See Also:

     Other setting functions: ‘set_breakdown()’, ‘set_cutoffs()’,
     ‘set_expanded_travel_times()’, ‘set_fare_cutoffs()’,
     ‘set_fare_structure()’, ‘set_max_fare()’, ‘set_max_lts()’,
     ‘set_max_rides()’, ‘set_monte_carlo_draws()’, ‘set_n_threads()’,
     ‘set_output_dir()’, ‘set_percentiles()’, ‘set_progress()’,
     ‘set_speed()’, ‘set_suboptimal_minutes()’, ‘set_verbose()’


--------------------------------------------------------------------------------
Function: set_verbose()
Set verbose argument

Description:

     Indicates whether R5 should output informative messages or not.
     Please note that R5 error messages are still reported even when
     ‘verbose’ is ‘FALSE’.

Usage:

     set_verbose(r5r_core, verbose)
     
Arguments:

r5r_core: An object to connect with the R5 routing engine, created with
          ‘setup_r5()’.

 verbose: A logical, passed from function above.

Value:

     Invisibly returns ‘TRUE’.

See Also:

     Other setting functions: ‘set_breakdown()’, ‘set_cutoffs()’,
     ‘set_expanded_travel_times()’, ‘set_fare_cutoffs()’,
     ‘set_fare_structure()’, ‘set_max_fare()’, ‘set_max_lts()’,
     ‘set_max_rides()’, ‘set_monte_carlo_draws()’, ‘set_n_threads()’,
     ‘set_output_dir()’, ‘set_percentiles()’, ‘set_progress()’,
     ‘set_speed()’, ‘set_suboptimal_minutes()’, ‘set_time_window()’


--------------------------------------------------------------------------------
Function: setup_fare_structure()
Setup a fare structure to calculate the monetary costs of trips

Description:

     Creates a basic fare structure that describes how transit fares
     should be calculated in ‘travel_time_matrix()’,
     ‘expanded_travel_time_matrix()’, ‘accessibility()’ and
     ‘pareto_frontier()’. This fare structure can be manually edited
     and adjusted to the existing rules in your study area, as long as
     they stick to some basic premises. Please see fare structure
     vignette for more information on how the fare structure works:
     ‘vignette("fare_structure", package = "r5r")’.

Usage:

     setup_fare_structure(
       r5r_core,
       base_fare,
       by = "MODE",
       debug_path = NULL,
       debug_info = NULL
     )
     
Arguments:

r5r_core: An object to connect with the R5 routing engine, created with
          ‘setup_r5()’.

base_fare: A numeric. A base value used to populate the fare structure.

      by: A string. Describes how ‘fare_type’s (a classification we
          created to assign fares to different routes) are distributed
          among routes. Possible values are ‘MODE’, ‘AGENCY’ and
          ‘GENERIC’. ‘MODE’ is used when the mode is what determines
          the price of a route (e.g. if all the buses of a given city
          cost $5). ‘AGENCY’ is used when the agency that operates each
          route is what determines its price (i.e. when two different
          routes/modes operated by a single agency cost the same; note
          that you can also use ‘AGENCY_NAME’, if the agency_ids listed
          in your GTFS cannot be easily interpreted). ‘GENERIC’ is used
          when all the routes cost the same. Please note that this
          classification can later be edited to better suit your needs
          (when, for example, two types of buses cost the same, but one
          offers discounts after riding the subway and the other one
          doesn't), but this parameter may save you some work.

debug_path: Either a path to a ‘.csv’ file or ‘NULL’. When ‘NULL’ (the
          default), fare debugging capabilities are disabled - i.e.
          there's no way to check if the fare calculation is correct.
          When a path is provided, ‘r5r’ saves different itineraries
          and their respective fares to the specified file. How each
          itinerary is described is controlled by ‘debug_info’.

debug_info: Either a string (when ‘debug_path’ is a path) or ‘NULL’
          (the default). Doesn't have any effect if ‘debug_path’ is
          ‘NULL’. When a string, accepts the values ‘MODE’, ‘ROUTE’ and
          ‘MODE_ROUTE’. These values dictates how itinerary information
          is written to the output. Let's suppose we have an itinerary
          composed by two transit legs: first a subway leg whose
          route_id is 001, and then a bus legs whose route_id is 007.
          If ‘debug_info’ is ‘MODE’, then this itinerary will be
          described as ‘SUBWAY|BUS’. If ‘ROUTE’, as ‘001|007’. If
          ‘MODE_ROUTE’, as SUBWAY 001|BUS 007. Please note that the
          final debug information will contain not only the itineraries
          that were in fact used in the itineraries returned in
          ‘travel_time_matrix()’, ‘accessibility()’ and
          ‘pareto_frontier()’, but all the itineraries that ‘R5’
          checked when calculating the routes. This imposes a
          performance penalty when tracking debug information (but has
          the positive effect of returning a larger sample of
          itineraries, which might help finding some implementation
          issues on the fare structure).

Value:

     A fare structure object.

See Also:

     Other fare structure: ‘read_fare_structure()’,
     ‘write_fare_structure()’

Examples:

     library(r5r)
     
     data_path <- system.file("extdata/poa", package = "r5r")
     r5r_core <- setup_r5(data_path)
     
     fare_structure <- setup_fare_structure(r5r_core, base_fare = 5)
     
     # to debug fare calculation
     fare_structure <- setup_fare_structure(
       r5r_core,
       base_fare = 5,
       debug_path = "fare_debug.csv",
       debug_info = "MODE"
     )
     
     fare_structure$debug_settings
     
     # debugging can be manually turned off by setting output_file to ""
     fare_structure$debug_settings <- ""
     

--------------------------------------------------------------------------------
Function: setup_r5()
Create a transport network used for routing in R5

Description:

     Builds a multimodal transport network used for routing in ‘R5’,
     combining multiple data inputs present in the directory where the
     network should be saved to. The directory must contain only one
     street network file (in ‘.osm.pbf’ format). It may optionally
     contain one or more public transport GTFS feeds (in ‘GTFS.zip’
     format, where ‘GTFS’ is the name of your feed), when used for
     public transport routing, and a ‘.tif’ file describing the
     elevation profile of the study area. If there is more than one
     GTFS feed in the directory, all feeds are merged. If there is
     already a 'network.dat' file in the directory, the function will
     simply read it and load it to memory (unless specified not to do
     so).

Usage:

     setup_r5(
       data_path,
       verbose = FALSE,
       temp_dir = FALSE,
       elevation = "TOBLER",
       overwrite = FALSE
     )
     
Arguments:

data_path: A string pointing to the directory where data inputs are
          stored and where the built ‘network.dat’ will be saved.

 verbose: A logical. Whether to show ‘R5’ informative messages when
          running the function. Defaults to ‘FALSE’ (please note that
          in such case ‘R5’ error messages are still shown). Setting
          ‘verbose’ to ‘TRUE’ shows detailed output, which can be
          useful for debugging issues not caught by ‘r5r’.

temp_dir: A logical. Whether the ‘R5’ Jar file should be saved to a
          temporary directory. Defaults to ‘FALSE’.

elevation: A string. The name of the impedance function to be used to
          calculate impedance for walking and cycling based on street
          slopes. Available options include ‘TOBLER’ (Default) and
          ‘MINETTI’, or ‘NONE’ to ignore elevation. R5 loads elevation
          data from ‘.tif’ files saved inside the ‘data_path’
          directory. See more info in the Details below.

overwrite: A logical. Whether to overwrite an existing ‘network.dat’ or
          to use a cached file. Defaults to ‘FALSE’ (i.e. use a cached
          network).

Value:

     An ‘rJava’ object to connect with ‘R5’ routing engine.

Details:

     More information about the ‘TOBLER’ and ‘MINETTI’ options to
     calculate the effects of elevation on travel times can be found in
     the references below:

        • Campbell, M. J., et al (2019). Using crowdsourced fitness
          tracker data to model the relationship between slope and
          travel rates. Applied geography, 106, 93-107.
          \Sexpr[results=rd]{tools:::Rd_expr_doi("10.1016/j.apgeog.2019.03.008")}.

        • Minetti, A. E., et al (2002). Energy cost of walking and
          running at extreme uphill and downhill slopes. Journal of
          applied physiology.
          \Sexpr[results=rd]{tools:::Rd_expr_doi("10.1152/japplphysiol.01177.2001")}.

        • Tobler, W. (1993). Three presentations on geographical
          analysis and modeling: Non-isotropic geographic modeling
          speculations on the geometry of geography global spatial
          analysis. Technical Report. National center for geographic
          information and analysis. 93 (1).
          <https://escholarship.org/uc/item/05r820mz>.

See Also:

     Other setup: ‘download_r5()’

Examples:

     library(r5r)
     
     # directory with street network and gtfs files
     data_path <- system.file("extdata/poa", package = "r5r")
     
     r5r_core <- setup_r5(data_path)
     

--------------------------------------------------------------------------------
Function: stop_r5()
Stop running r5r core

Description:

     Stops running r5r cores.

Usage:

     stop_r5(...)
     
Arguments:

     ...: ‘r5r_core’ objects currently running. By default, if no cores
          are supplied all running cores are stopped.

Value:

     No return value, called for side effects.

See Also:

     Other support functions: ‘fileurl_from_metadata()’

Examples:

     library(r5r)
     
     path <- system.file("extdata/poa", package = "r5r")
     
     r5r_core <- setup_r5(path)
     
     stop_r5(r5r_core)
     

--------------------------------------------------------------------------------
Function: street_network_to_sf()
Extract OpenStreetMap network in sf format from a network.dat file

Description:

     Extract OpenStreetMap network in sf format from a network.dat file

Usage:

     street_network_to_sf(r5r_core)
     
Arguments:

r5r_core: An object to connect with the R5 routing engine, created with
          ‘setup_r5()’.

Value:

     A list with two components of a street network in sf format:
     vertices (POINT) and edges (LINESTRING).

See Also:

     Other network functions: ‘find_snap()’, ‘transit_network_to_sf()’

Examples:

     library(r5r)
     
     # build transport network
     path <- system.file("extdata/poa", package = "r5r")
     r5r_core <- setup_r5(path)
     
     # extract street network from r5r_core
     street_net <- street_network_to_sf(r5r_core)
     
     stop_r5(r5r_core)
     

--------------------------------------------------------------------------------
Function: transit_network_to_sf()
Extract transit network in sf format

Description:

     Extracts the transit network from a ‘network.dat’ file (built with
     ‘setup_r5()’) in ‘sf’ format.

Usage:

     transit_network_to_sf(r5r_core)
     
Arguments:

r5r_core: An object to connect with the R5 routing engine, created with
          ‘setup_r5()’.

Value:

     A list with two components of a transit network in ‘sf’ format:
     route shapes (‘LINESTRING’) and transit stops (‘POINT’). The same
     ‘route_id’/‘short_name’ might appear with different geometries.
     This occurs when the same route is associated to more than one
     ‘shape_id’s in the GTFS feed used to create the transit network.
     Some transit stops might be returned with geometry POINT EMPTY
     (i.e. missing spatial coordinates). This may occur when a transit
     stop is not snapped to the road network, possibly because the GTFS
     feed used to create the transit network covers an area larger than
     the ‘.osm.pbf’ input data.

See Also:

     Other network functions: ‘find_snap()’, ‘street_network_to_sf()’

Examples:

     library(r5r)
     
     # build transport network
     path <- system.file("extdata/poa", package = "r5r")
     r5r_core <- setup_r5(path)
     
     # extract transit network from r5r_core
     transit_net <- transit_network_to_sf(r5r_core)
     
     stop_r5(r5r_core)
     

--------------------------------------------------------------------------------
Function: travel_time_matrix()
Calculate travel time matrix between origin destination pairs

Description:

     Fast computation of travel time estimates between one or multiple
     origin destination pairs.

Usage:

     travel_time_matrix(
       r5r_core,
       origins,
       destinations,
       mode = "WALK",
       mode_egress = "WALK",
       departure_datetime = Sys.time(),
       time_window = 10L,
       percentiles = 50L,
       fare_structure = NULL,
       max_fare = Inf,
       max_walk_time = Inf,
       max_bike_time = Inf,
       max_car_time = Inf,
       max_trip_duration = 120L,
       walk_speed = 3.6,
       bike_speed = 12,
       max_rides = 3,
       max_lts = 2,
       draws_per_minute = 5L,
       n_threads = Inf,
       verbose = FALSE,
       progress = FALSE,
       output_dir = NULL
     )
     
Arguments:

r5r_core: An object to connect with the R5 routing engine, created with
          ‘setup_r5()’.

origins, destinations: Either a POINT sf object with WGS84 CRS, or a
          ‘data.frame’ containing the columns ‘id’, ‘lon’ and ‘lat’.

    mode: A character vector. The transport modes allowed for access,
          transfer and vehicle legs of the trips. Defaults to ‘WALK’.
          Please see details for other options.

mode_egress: A character vector. The transport mode used after egress
          from the last public transport. It can be either ‘WALK’,
          ‘BICYCLE’ or ‘CAR’. Defaults to ‘WALK’. Ignored when public
          transport is not used.

departure_datetime: A POSIXct object. Please note that the departure
          time only influences public transport legs. When working with
          public transport networks, please check the ‘calendar.txt’
          within your GTFS feeds for valid dates. Please see details
          for further information on how datetimes are parsed.

time_window: An integer. The time window in minutes for which ‘r5r’
          will calculate multiple travel time matrices departing each
          minute. Defaults to 10 minutes. By default, the function
          returns the result based on median travel times, but the user
          can set the ‘percentiles’ parameter to extract more results.
          Please read the time window vignette for more details on its
          usage ‘vignette("time_window", package = "r5r")’

percentiles: An integer vector (max length of 5). Specifies the
          percentile to use when returning travel time estimates within
          the given time window. For example, if the 25th travel time
          percentile between A and B is 15 minutes, 25% of all trips
          taken between these points within the specified time window
          are shorter than 15 minutes. Defaults to 50, returning the
          median travel time. If a vector with length bigger than 1 is
          passed, the output contains an additional column for each
          percentile specifying the percentile travel time estimate.
          each estimate. Due to upstream restrictions, only 5
          percentiles can be specified at a time. For more details,
          please see R5 documentation at
          <https://docs.conveyal.com/analysis/methodology#accounting-for-variability>.

fare_structure: A fare structure object, following the convention set
          in ‘setup_fare_structure()’. This object describes how
          transit fares should be calculated. Please see the fare
          structure vignette to understand how this object is
          structured: ‘vignette("fare_structure", package = "r5r")’.

max_fare: A number. The maximum value that trips can cost when
          calculating the fastest journey between each origin and
          destination pair.

max_walk_time: An integer. The maximum walking time (in minutes) to
          access and egress the transit network, to make transfers
          within the network or to complete walk-only trips. Defaults
          to no restrictions (numeric value of ‘Inf’), as long as
          ‘max_trip_duration’ is respected. When routing transit trips,
          the max time is considered separately for each leg (e.g. if
          you set ‘max_walk_time’ to 15, you could get trips with an up
          to 15 minutes walk leg to reach transit and another up to 15
          minutes walk leg to reach the destination after leaving
          transit. In walk-only trips, whenever ‘max_walk_time’ differs
          from ‘max_trip_duration’, the lowest value is considered.

max_bike_time: An integer. The maximum cycling time (in minutes) to
          access and egress the transit network, to make transfers
          within the network or to complete bicycle-only trips.
          Defaults to no restrictions (numeric value of ‘Inf’), as long
          as ‘max_trip_duration’ is respected. When routing transit
          trips, the max time is considered separately for each leg
          (e.g. if you set ‘max_bike_time’ to 15, you could get trips
          with an up to 15 minutes cycle leg to reach transit and
          another up to 15 minutes cycle leg to reach the destination
          after leaving transit. In bicycle-only trips, whenever
          ‘max_bike_time’ differs from ‘max_trip_duration’, the lowest
          value is considered.

max_car_time: An integer. The maximum driving time (in minutes) to
          access and egress the transit network. Defaults to no
          restrictions, as long as ‘max_trip_duration’ is respected.
          The max time is considered separately for each leg (e.g. if
          you set ‘max_car_time’ to 15 minutes, you could potentially
          drive up to 15 minutes to reach transit, and up to _another_
          15 minutes to reach the destination after leaving transit).
          Defaults to ‘Inf’, no limit.

max_trip_duration: An integer. The maximum trip duration in minutes.
          Defaults to 120 minutes (2 hours).

walk_speed: A numeric. Average walk speed in km/h. Defaults to 3.6
          km/h.

bike_speed: A numeric. Average cycling speed in km/h. Defaults to 12
          km/h.

max_rides: An integer. The maximum number of public transport rides
          allowed in the same trip. Defaults to 3.

 max_lts: An integer between 1 and 4. The maximum level of traffic
          stress that cyclists will tolerate. A value of 1 means
          cyclists will only travel through the quietest streets, while
          a value of 4 indicates cyclists can travel through any road.
          Defaults to 2. Please see details for more information.

draws_per_minute: An integer. The number of Monte Carlo draws to
          perform per time window minute when calculating travel time
          matrices and when estimating accessibility. Defaults to 5.
          This would mean 300 draws in a 60-minute time window, for
          example. This parameter only affects the results when the
          GTFS feeds contain a ‘frequencies.txt’ table. If the GTFS
          feed does not have a frequency table, r5r still allows for
          multiple runs over the set ‘time_window’ but in a
          deterministic way.

n_threads: An integer. The number of threads to use when running the
          router in parallel. Defaults to use all available threads
          (Inf).

 verbose: A logical. Whether to show ‘R5’ informative messages when
          running the function. Defaults to ‘FALSE’ (please note that
          in such case ‘R5’ error messages are still shown). Setting
          ‘verbose’ to ‘TRUE’ shows detailed output, which can be
          useful for debugging issues not caught by ‘r5r’.

progress: A logical. Whether to show a progress counter when running
          the router. Defaults to ‘FALSE’. Only works when ‘verbose’ is
          set to ‘FALSE’, so the progress counter does not interfere
          with ‘R5’'s output messages. Setting ‘progress’ to ‘TRUE’ may
          impose a small penalty for computation efficiency, because
          the progress counter must be synchronized among all active
          threads.

output_dir: Either ‘NULL’ or a path to an existing directory. When not
          ‘NULL’ (the default), the function will write one ‘.csv’ file
          with the results for each origin in the specified directory.
          In such case, the function returns the path specified in this
          parameter. This parameter is particularly useful when running
          on memory-constrained settings because writing the results
          directly to disk prevents ‘r5r’ from loading them to RAM
          memory.

Value:

     A ‘data.table’ with travel time estimates (in minutes) between
     origin and destination pairs. Pairs whose trips couldn't be
     completed within the maximum travel time and/or whose origin is
     too far from the street network are not returned in the
     ‘data.table’. If ‘output_dir’ is not ‘NULL’, the function returns
     the path specified in that parameter, in which the ‘.csv’ files
     containing the results are saved.

Transport modes:

     ‘R5’ allows for multiple combinations of transport modes. The
     options include:

        • *Transit modes:* ‘TRAM’, ‘SUBWAY’, ‘RAIL’, ‘BUS’, ‘FERRY’,
          ‘CABLE_CAR’, ‘GONDOLA’, ‘FUNICULAR’. The option ‘TRANSIT’
          automatically considers all public transport modes available.

        • *Non transit modes:* ‘WALK’, ‘BICYCLE’, ‘CAR’,
          ‘BICYCLE_RENT’, ‘CAR_PARK’.

Level of Traffic Stress (LTS):

     When cycling is enabled in ‘R5’ (by passing the value ‘BIKE’ to
     either ‘mode’ or ‘mode_egress’), setting ‘max_lts’ will allow
     cycling only on streets with a given level of danger/stress.
     Setting ‘max_lts’ to 1, for example, will allow cycling only on
     separated bicycle infrastructure or low-traffic streets and
     routing will revert to walking when traversing any links with LTS
     exceeding 1. Setting ‘max_lts’ to 3 will allow cycling on links
     with LTS 1, 2 or 3. Routing also reverts to walking if the street
     segment is tagged as non-bikable in OSM (e.g. a staircase),
     independently of the specified max LTS.

     The default methodology for assigning LTS values to network edges
     is based on commonly tagged attributes of OSM ways. See more info
     about LTS in the original documentation of R5 from Conveyal at
     <https://docs.conveyal.com/learn-more/traffic-stress>. In summary:

        • *LTS 1*: Tolerable for children. This includes low-speed,
          low-volume streets, as well as those with separated bicycle
          facilities (such as parking-protected lanes or cycle tracks).

        • *LTS 2*: Tolerable for the mainstream adult population. This
          includes streets where cyclists have dedicated lanes and only
          have to interact with traffic at formal crossing.

        • *LTS 3*: Tolerable for "enthused and confident" cyclists.
          This includes streets which may involve close proximity to
          moderate- or high-speed vehicular traffic.

        • *LTS 4*: Tolerable only for "strong and fearless" cyclists.
          This includes streets where cyclists are required to mix with
          moderate- to high-speed vehicular traffic.

     For advanced users, you can provide custom LTS values by adding a
     tag <key = "lts"> to the ‘osm.pbf’ file.

Datetime parsing:

     ‘r5r’ ignores the timezone attribute of datetime objects when
     parsing dates and times, using the study area's timezone instead.
     For example, let's say you are running some calculations using Rio
     de Janeiro, Brazil, as your study area. The datetime
     ‘as.POSIXct("13-05-2019 14:00:00", format = "%d-%m-%Y %H:%M:%S")’
     will be parsed as May 13th, 2019, 14:00h in Rio's local time, as
     expected. But ‘as.POSIXct("13-05-2019 14:00:00", format =
     "%d-%m-%Y %H:%M:%S", tz = "Europe/Paris")’ will also be parsed as
     the exact same date and time in Rio's local time, perhaps
     surprisingly, ignoring the timezone attribute.

Routing algorithm:

     The ‘travel_time_matrix()’, ‘expanded_travel_time_matrix()’ and
     ‘accessibility()’ functions use an ‘R5’-specific extension to the
     RAPTOR routing algorithm (see Conway et al., 2017). This RAPTOR
     extension uses a systematic sample of one departure per minute
     over the time window set by the user in the 'time_window'
     parameter. A detailed description of base RAPTOR can be found in
     Delling et al (2015). However, whenever the user includes transit
     fares inputs to these functions, they automatically switch to use
     an ‘R5’-specific extension to the McRAPTOR routing algorithm.

        • Conway, M. W., Byrd, A., & van der Linden, M. (2017).
          Evidence-based transit and land use sketch planning using
          interactive accessibility methods on combined schedule and
          headway-based networks. Transportation Research Record,
          2653(1), 45-53.
          \Sexpr[results=rd]{tools:::Rd_expr_doi("10.3141/2653-06")}

        • Delling, D., Pajor, T., & Werneck, R. F. (2015). Round-based
          public transit routing. Transportation Science, 49(3),
          591-604.
          \Sexpr[results=rd]{tools:::Rd_expr_doi("10.1287/trsc.2014.0534")}

See Also:

     Other routing: ‘detailed_itineraries()’,
     ‘expanded_travel_time_matrix()’, ‘pareto_frontier()’

Examples:

     library(r5r)
     
     # build transport network
     data_path <- system.file("extdata/poa", package = "r5r")
     r5r_core <- setup_r5(data_path)
     
     # load origin/destination points
     points <- read.csv(file.path(data_path, "poa_points_of_interest.csv"))
     
     departure_datetime <- as.POSIXct(
       "13-05-2019 14:00:00",
       format = "%d-%m-%Y %H:%M:%S"
     )
     
     ttm <- travel_time_matrix(
       r5r_core,
       origins = points,
       destinations = points,
       mode = c("WALK", "TRANSIT"),
       departure_datetime = departure_datetime,
       max_trip_duration = 60
     )
     head(ttm)
     
     # using a larger time window
     ttm <- travel_time_matrix(
       r5r_core,
       origins = points,
       destinations = points,
       mode = c("WALK", "TRANSIT"),
       departure_datetime = departure_datetime,
       time_window = 30,
       max_trip_duration = 60
     )
     head(ttm)
     
     # selecting different percentiles
     ttm <- travel_time_matrix(
       r5r_core,
       origins = points,
       destinations = points,
       mode = c("WALK", "TRANSIT"),
       departure_datetime = departure_datetime,
       time_window = 30,
       percentiles = c(25, 50, 75),
       max_trip_duration = 60
     )
     head(ttm)
     
     # use a fare structure and set a max fare to take monetary constraints into
     # account
     fare_structure <- read_fare_structure(
       file.path(data_path, "fares/fares_poa.zip")
     )
     ttm <- travel_time_matrix(
       r5r_core,
       origins = points,
       destinations = points,
       mode = c("WALK", "TRANSIT"),
       departure_datetime = departure_datetime,
       fare_structure = fare_structure,
       max_fare = 5,
       max_trip_duration = 60,
     )
     head(ttm)
     
     stop_r5(r5r_core)
     

--------------------------------------------------------------------------------
Function: write_fare_structure()
Write a fare structure object to disk

Description:

     Writes a fare structure object do disk. Fare structure is saved as
     a collection of ‘.csv’ files inside a ‘.zip’ file.

Usage:

     write_fare_structure(fare_structure, file_path)
     
Arguments:

fare_structure: A fare structure object, following the convention set
          in ‘setup_fare_structure()’. This object describes how
          transit fares should be calculated. Please see the fare
          structure vignette to understand how this object is
          structured: ‘vignette("fare_structure", package = "r5r")’.

file_path: A path to a ‘.zip’ file. Where the fare structure should be
          written to.

Value:

     The path passed to ‘file_path’, invisibly.

See Also:

     Other fare structure: ‘read_fare_structure()’,
     ‘setup_fare_structure()’

Examples:

     library(r5r)
     
     data_path <- system.file("extdata/poa", package = "r5r")
     r5r_core <- setup_r5(data_path)
     
     fare_structure <- setup_fare_structure(r5r_core, base_fare = 5)
     
     tmpfile <- tempfile("sample_fare_structure", fileext = ".zip")
     write_fare_structure(fare_structure, tmpfile)
     


--------------------------------------------------------------------------------
Vignette: accessibility.Rmd

---
title: 'Accessibility'
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
abstract: "This vignette shows how to calculate and visualize accessibility in R using the `r5r` package."
urlcolor: blue
vignette: >
  %\VignetteIndexEntry{Accessibility} 
  %\VignetteEngine{knitr::rmarkdown} 
  \usepackage[utf8]{inputenc}
bibliography: references.json
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  eval = identical(tolower(Sys.getenv("NOT_CRAN")), "true"),
  out.width = "100%"
)
```

# 1. Introduction 

Accessibility indicators measure the ease with which opportunities, such as jobs,
can be reached by a traveler from a particular location [@levinson2020manual]. This vignette shows how to calculate and visualize accessibility in R using the [`r5r` package](https://ipeagit.github.io/r5r/index.html) using a reproducible example. In this example, we will be using a sample data set for the city of Porto Alegre (Brazil) included in `r5r`. 

There are two ways to calculate / visualize accessibility using `r5r`. The quick and easy option is using the `r5r::accessibility()` function. The other alternative requires one to first calculate a travel time matrix, and then to use the [{accessibility} package](https://ipeagit.github.io/accessibility/). This is a more flexible options because the `{accessibility}` package provides a wider range of options of accessibility metrics. We will cover both approaches in this vignette. 

Before we start, we need to increase Java memory + load a few libraries, and to build routable transport network.


# 2. Build routable transport network with `setup_r5()`

### Increase Java memory and load libraries

First, we need to increase the memory available to Java and load the packages used in this vignette. Please note we allocate RAM memory to Java *before* loading our libraries.

```{r, message = FALSE}
options(java.parameters = "-Xmx2G")

library(r5r)
library(accessibility)
library(sf)
library(data.table)
library(ggplot2)
library(interp)
library(h3jsr)
library(dplyr)
```
To build a routable transport network with `r5r`, the user needs to call `setup_r5()` with the path to the directory where OpenStreetMap and GTFS data are stored.

```{r, message = FALSE}
# system.file returns the directory with example data inside the r5r package
# set data path to directory containing your own data if not running this example
data_path <- system.file("extdata/poa", package = "r5r")

r5r_core <- setup_r5(data_path)
```


# 3. Accessibility: quick and easy approach

There are different types of accessibility metrics. One of the simplest ones is the cumulative-opportunity metric, which counts the number of opportunities accessible from each location considering a maximum travel time cutoff. This is what we'll be calculating in this vignette using the parameter `decay_function = "step"`.

In this example, we will be calculating the number of schools and public healthcare facilities accessible by public transport within a travel time of up to 20 minutes. The sample data provided contains information on the spatial distribution of schools in Porto Alegre in the `points$schools` column, and healthcare facilities in the `points$healthcare` column. 

With the code below we compute the number of schools and healthcare accessible considering median of multiple travel time estimates departing every minute over a 60-minute time window, between 2pm and 3pm. The `accessibility()` function can calculate access to multiple opportunities in a single call, which is much more efficient and convenient than producing a travel time matrix of the study area and manually computing accessibility.


```{r, message = FALSE}
# read all points in the city
points <- fread(file.path(data_path, "poa_hexgrid.csv"))

# routing inputs
mode <- c("WALK", "TRANSIT")
max_walk_time <- 30      # in minutes
travel_time_cutoff <- 20 # in minutes
time_window <- 60        # in minutes
departure_datetime <- as.POSIXct("13-05-2019 14:00:00",
                                 format = "%d-%m-%Y %H:%M:%S")

# calculate accessibility
access1 <- r5r::accessibility(r5r_core,
                        origins = points,
                        destinations = points,
                        mode = mode,
                        opportunities_colnames = c("schools", "healthcare"),
                        decay_function = "step",
                        cutoffs = travel_time_cutoff,
                        departure_datetime = departure_datetime,
                        max_walk_time = max_walk_time,
                        time_window = time_window,
                        progress = FALSE)

head(access1)
```


Mind you that the `r5r::accessibility()` also allow users to calculate gravity-based accessibility metrics, which can be calculated by setting the `decay_function` to one of the following: `"exponential"` `"fixed_exponential"`, `"linear"` or `"logistic"`. Nonetheless, there are several other types of accessibility metrics not implemented in R5, including floating catchment area metrics, travel cost to closest N opportunities, time interval based cumulative opportunity, etc. This is where the `{accessibility}` package comes in.


# 4. Accessibility: flexible approach

The `{accessibility}` package provides a much more flexible approach to calculate accessibility estimates. A key input here is a [travel time matrix](https://ipeagit.github.io/r5r/articles/travel_time_matrix.html), which we calculate using `r5r`:

```{r, message = FALSE}
# calculate travel time matrix
ttm <- r5r::travel_time_matrix(r5r_core,
                        origins = points,
                        destinations = points,
                        mode = mode,
                        departure_datetime = departure_datetime,
                        max_walk_time = max_walk_time,
                        time_window = time_window,
                        progress = FALSE)
head(ttm)
```
Now to calculate a traditional cumulative opportunity metric like we did above, we just need to call the `accessibility::cumulative_cutoff()` function, and pass our travel time matrix and land use data as input:

```{r, message = FALSE}
# calculate accessibility
access_edu <- accessibility::cumulative_cutoff(travel_matrix = ttm, 
                                        land_use_data = points,
                                        opportunity = 'schools',
                                        travel_cost = 'travel_time_p50',
                                        cutoff = 20)

access_health <- accessibility::cumulative_cutoff(travel_matrix = ttm, 
                                        land_use_data = points,
                                        opportunity = 'healthcare',
                                        travel_cost = 'travel_time_p50',
                                        cutoff = 20)
head(access_edu)
head(access_health)
```


# 5. Map Accessibility

The final step is mapping the accessibility results calculated earlier. We can use at least two different approaches to map our accessibility estimates.

## 5.1 Choropleth maps

The first approach is to use choropleth maps. In our example, each point of reference is the centroid of a H3 hexagonal grid at a fine spatial resolution. In this case, we basically need to retrieve the polygons of the spatial grid, and merge it with our accessibility estimates.

```{r, message = FALSE, out.width='100%'}
# retrieve polygons of H3 spatial grid
grid <- h3jsr::cell_to_polygon(points$id, simple = FALSE)

# merge accessibility estimates
access_sf <- left_join(grid, access1, by = c('h3_address'='id'))

# plot
ggplot() +
  geom_sf(data = access_sf, aes(fill = accessibility), color= NA) +
  scale_fill_viridis_c(direction = -1, option = 'B') +
  labs(fill = "Number of\nfacilities within\n20 minutes") +
  theme_minimal() +
  theme(axis.title = element_blank()) +
  facet_wrap(~opportunity) +
  theme_void()

```


## 5.2 Spatial interpolation

An alternative approach is to use our accessibility estimates for each reference point and do some spatial interpolation so we can have a smoother spatial distribution. The code below demonstrates how to do that, producing a prettier map.

```{r, message = FALSE, out.width='100%'}
# interpolate estimates to get spatially smooth result
access_schools <- access1 %>% 
  filter(opportunity == "schools") %>%
  inner_join(points, by='id') %>%
  with(interp::interp(lon, lat, accessibility)) %>%
  with(cbind(acc=as.vector(z),  # Column-major order
             x=rep(x, times=length(y)),
             y=rep(y, each=length(x)))) %>% as.data.frame() %>% na.omit() %>%
  mutate(opportunity = "schools")

access_health <- access1 %>% 
  filter(opportunity == "healthcare") %>%
  inner_join(points, by='id') %>%
  with(interp::interp(lon, lat, accessibility)) %>%
  with(cbind(acc=as.vector(z),  # Column-major order
             x=rep(x, times=length(y)),
             y=rep(y, each=length(x)))) %>% as.data.frame() %>% na.omit() %>%
  mutate(opportunity = "healthcare")

access.interp <- rbind(access_schools, access_health)

# find results' bounding box to crop the map
bb_x <- c(min(access.interp$x), max(access.interp$x))
bb_y <- c(min(access.interp$y), max(access.interp$y))

# extract OSM network, to plot over map
street_net <- street_network_to_sf(r5r_core)

# plot
ggplot(na.omit(access.interp)) +
  geom_sf(data = street_net$edges, color = "gray55", size=0.01, alpha = 0.7) +
  geom_contour_filled(aes(x=x, y=y, z=acc), alpha=.7) +
  scale_fill_viridis_d(direction = -1, option = 'B') +
  scale_x_continuous(expand=c(0,0)) +
  scale_y_continuous(expand=c(0,0)) +
  coord_sf(xlim = bb_x, ylim = bb_y, datum = NA) + 
  labs(fill = "Number of\nfacilities within\n20 minutes") +
  theme_void() +
  facet_wrap(~opportunity)
```


### Cleaning up after usage

`r5r` objects are still allocated to any amount of memory previously set after they are done with their calculations. In order to remove an existing `r5r` object and reallocate the memory it had been using, we use the `stop_r5` function followed by a call to Java's garbage collector, as follows:

```{r, message = FALSE}
r5r::stop_r5(r5r_core)
rJava::.jgc(R.gc = TRUE)
```

If you have any suggestions or want to report an error, please visit [the package GitHub page](https://github.com/ipeaGIT/r5r).

## References



--------------------------------------------------------------------------------
Vignette: detailed_itineraries.Rmd

---
title: 'Trip planning with detailed_itineraries()'
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
abstract: "This vignette shows how to do route planning using the `detailed_itineraries()` function in r5r."
urlcolor: blue
vignette: >
  %\VignetteIndexEntry{Trip planning with detailed_itineraries()} 
  %\VignetteEngine{knitr::rmarkdown} 
  \usepackage[utf8]{inputenc}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  eval = identical(tolower(Sys.getenv("NOT_CRAN")), "true"),
  out.width = "100%"
)
```




# 1. Introduction 

**r5r** has some extremely efficient functions to run multimodal routing and accessibility analysis. In general, though, these functions output only the essential information required by most transport planning applications and simulation models. Moreover, the algorithms behind these function return only the optimal route in terms of minimizing travel times and/or monetary costs. Sometimes, though, we would like to do more simple route planning analysis and extract more information for each route. Also, we might be interested in finding not only the fastest route but some other suboptimal route alternatives too.

This is where the `detailed_itineraries()` function comes in. This function outputs for each origin destination pair a detailed route plan with information per leg, meaning a route taken by a single mode such as a walk to the bus stop. In R5's documentation these legs are referred to as 'segments', a word more usually used to describe small sections on the transport network. Results contain information on the mode, waiting times, travel times and distances for each leg (or 'segment' in R5 documentation) and the trip geometry. Moreover, the `detailed_itineraries()` function can also return results for multiple route alternatives. Let's see how this function works using a reproducible example.
 

**obs.** We only recommend using `detailed_itineraries()` in case you are interested in finding suboptimal alternative routes and/or need the geometry information of the outputs. If you only want to have route information detailed by trip segments, then we would strongly encourage you to use the `expanded_travel_time_matrix()` function. More info here.

# 2. Build routable transport network with `setup_r5()`

First, let's load some libraries and build our multimodal transport network. In this example we'll be using the a sample data set for the city of Porto Alegre (Brazil) included in `r5r`.

```{r, message = FALSE}
# increase Java memory
options(java.parameters = "-Xmx2G")

# load libraries
library(r5r)
library(sf)
library(ggplot2)
library(data.table)

# build a routable transport network with r5r
data_path <- system.file("extdata/poa", package = "r5r")
r5r_core <- setup_r5(data_path)

# routing inputs
mode <- c('walk', 'transit')
max_trip_duration <- 60 # minutes

# departure time
departure_datetime <- as.POSIXct("13-05-2019 14:00:00", 
                                 format = "%d-%m-%Y %H:%M:%S")

# load origin/destination points
poi <- fread(file.path(data_path, "poa_points_of_interest.csv"))

```


# 3. Detailed info by trip segment for multiple trip alternatives

In this example below, we want to know some alternative routes between a single origin/destination pair. To get multiple route alternatives, we need to set `shortest_path = FALSE`.

Note that in the example below we set `suboptimal_minutes = 8`. In this case, `r5r` will consider sub-optimal routes that arrive up to 10 minutes after the arrival of the optimal route.

```{r, message = FALSE}
# set inputs
origins <- poi[10,]
destinations <- poi[12,]
mode <- c("WALK", "TRANSIT")
max_walk_time <- 60
departure_datetime <- as.POSIXct("13-05-2019 14:00:00",
                                 format = "%d-%m-%Y %H:%M:%S")

# calculate detailed itineraries
det <- detailed_itineraries(r5r_core = r5r_core,
                            origins = origins,
                            destinations = destinations,
                            mode = mode,
                            departure_datetime = departure_datetime,
                            max_walk_time = max_walk_time,
                            suboptimal_minutes = 8,
                            shortest_path = FALSE)

head(det)
```
```{r detailed head, echo = FALSE, out.width='100%', message = FALSE, eval = FALSE}
knitr::include_graphics("https://github.com/ipeaGIT/r5r/blob/master/r-package/inst/img/vig_output_detailed.png?raw=true")
```


The output is a `data.frame sf` object, so we can easily visualize the results.

## 3.1 Visualize results

**Static visualization** with `ggplot2` package: To provide a geographic context 
for the visualization of the results in `ggplot2`, you can also use the `street_network_to_sf((` function to  extract the OSM street network used in the routing.

```{r, message = FALSE}
# extract OSM network
street_net <- street_network_to_sf(r5r_core)

# extract public transport network
transit_net <- r5r::transit_network_to_sf(r5r_core)

# plot
fig <- ggplot() +
        geom_sf(data = street_net$edges, color='gray85') +
        geom_sf(data = subset(det, option <4), aes(color=mode)) +
        facet_wrap(.~option) + 
        theme_void()

fig
```
```{r, message = FALSE, eval = FALSE}
# SAVE image
ggsave(plot = fig, filename = 'inst/img/vig_detailed_ggplot.png', 
       height = 5, width = 15, units='cm', dpi=200)
```

```{r ggplot2 output, echo = FALSE, out.width='100%', message = FALSE, eval = FALSE}
knitr::include_graphics("https://github.com/ipeaGIT/r5r/blob/master/r-package/inst/img/vig_detailed_ggplot.png?raw=true")
```

# 4. A few options:

### 4.1 Combining orings and destinations

- By default, `detailed_itineraries()` will query routes between the 1st origin to the 1st destination, then the 2nd origin to the 2nd destination, and so on. If you would like to query routes between all origins to all destinations you can simply set `all_to_all = TRUE`.

### 4.2 Keep geometry data in the output

- Be default, `detailed_itineraries()` will not return the spatial geometry of results. To retrieve this information you can simply set `geometry = TRUE`.



# 5. Hack for frequency-based GTFS feeds

Please note that the `detailed_itineraries()` functions does not run on frequency-based GTFS feeds. A simple hack to overcome this problem is to convert your GTFS data from frequencies to time tables. This can be easily done using the [`gtfstools` package](https://ipeagit.github.io/gtfstools/). Here is how:

```{r, message = FALSE, eval = FALSE}
library(gtfstools)

# location of your frequency-based GTFS
freq_gtfs_file <- system.file("extdata/spo/spo.zip", package = "r5r")

# read GTFS data
freq_gtfs <- gtfstools::read_gtfs(freq_gtfs_file)

# convert from frequencies to time tables
stop_times_gtfs <- gtfstools::frequencies_to_stop_times(freq_gtfs)

# save it as a new GTFS.zip file
gtfstools::write_gtfs(gtfs = stop_times_gtfs,
                      path = tempfile(pattern = 'stop_times_gtfs', fileext = '.zip'))


```

... and now you can use `r5r` on this `stop_times_gtfs.zip`.

### Cleaning up after usage

`r5r` objects are still allocated to any amount of memory previously set after they are done with their calculations. In order to remove an existing `r5r` object and reallocate the memory it had been using, we use the `stop_r5` function followed by a call to Java's garbage collector, as follows:

```{r, message = FALSE}
r5r::stop_r5(r5r_core)
rJava::.jgc(R.gc = TRUE)
```

If you have any suggestions or want to report an error, please visit [the package GitHub page](https://github.com/ipeaGIT/r5r).



--------------------------------------------------------------------------------
Vignette: faq.Rmd

---
title: 'FAQ - Frequently Asked Questions'
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
abstract: "A short list of responses and clarifications about Frequently Asked Questions from r5r users."
urlcolor: blue
vignette: >
  %\VignetteIndexEntry{FAQ - Frequently Asked Questions} 
  %\VignetteEngine{knitr::rmarkdown} 
  \usepackage[utf8]{inputenc}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  eval = identical(tolower(Sys.getenv("NOT_CRAN")), "true"),
  out.width = "100%"
)

```

# 1. Why do some trips from/to the same ID have travel times larger than zero?

<details><summary>click to expand</summary>

> This can happen when the input point is distant to any routable road segment. In this case, R5 will snap the point to the closest road segment that can be traversed with the selected transport mode, and it will consider that the person would walk in Euclidean distance from the input point to the snapped location. So R5 is accounting for this walking time "as the crow flies" in the routing.

</details>



# 2. Is it possible to run `r5r` with custom modifications to street nework data?

<details><summary>click to expand</summary>

> It is possible to edit the OpenStreetMap `.pbf` file before using it in `r5r` for example to remove or add roads, change speeds etc etc. To to this, you can edit the `.pbf` file with [JOSM (https://wiki.openstreetmap.org/wiki/JOSM)](https://wiki.openstreetmap.org/wiki/JOSM). Mind you that the the OpenStreetMap tags can be changed but they cannot be removed from the data.

</details>




# 3. Why are the output results of `time_travel_matrix()` and `detailed_itineraries()` different?
  
<details><summary>click to expand</summary>

> The functions `time_travel_matrix()` (and `expanded_time_travel_matrix`) and `detailed_itineraries()` use different routing algorithms, as explained in the documentation of these functions. As such, we advise not to use or combine the output of these functions.

</details>




# 4. What does the ERROR "Geographic extent of street layer exceeds limit" mean? and what to do about it?

<details><summary>click to expand</summary>

> If you an error message says something like: *"Geographic extent of street layer (5315196 km2) exceeds limit of 975000 km2"*. This means the your study area is too large. Unfortunately, this is a limit hardcoded upstream in R5 so we cannot change it in r5r. The advised **solution** here would be to reduce the extent of the `OpenStreetMap.pbf` to a smaller area of interest. One can do this using the [Osmosis](https://wiki.openstreetmap.org/wiki/Osmosis) software. The code below illustrates how to do this by calling Osmosis from within R. You need to donwload the Osmosis program to your computer. The latest releases can be downloaded from [here](https://github.com/openstreetmap/osmosis/releases). Next, you can use this step-by-step illustrated in the example below:

```
# get the bounding box of your study area
study_area_polygon <- geobr::read_state(code_state = "ES")
area_bbox <- sf::st_bbox(study_area_polygon)

# input: the path to osmosis and the large pbf file in your local computer
osmosis_path <- "./osmosis_dir/bin/osmosis.bat"
large_pbf_path <- "./project_dir/large.pbf"

# path where you want to save the smaller .pbf file
smaller_pbf <-"./project_dir/smaller.pbf"

# prepare call to osmosis
osmosis_cmd <- sprintf("%s --read-pbf %s --bounding-box left=%s bottom=%s right=%s top=%s --write-pbf %s",
                       osmosis_path, large_pbf_path, 
                       area_bbox@xmin, area_bbox@ymin, area_bbox@xmax, area_bbox@ymax,
                       smaller_pbf)

# call to osmosis
shell(osmosis_cmd, translate = TRUE)
```
</details>



# 5. Is it possible to use custom car speed data with r5r?

<details><summary>click to expand</summary>

> By default, R5 considers the max speed limit of each road as set in OpenStreetMap data. Unfortunately, there is currently no easy way to change the car speeds of road segments from within R. Although you could probably do that by editing the osm.pbf file using other programs. See issue [#289](https://github.com/ipeaGIT/r5r/issues/289).

</details>




# 6. Why do I get identical results by public transport and walking?

<details><summary>click to expand</summary>

> If your travel time / accessibility results are identical for public transport and walking, it is probably because R5 did not detect that the public transport network is available for your requested trips. This is likely to occur in case you set a `departure_datetime` outside the calendar of public transport operations in your GTFS data. Check the `calendar.txt` file in your gtfs.zip feed. Alternatively, this could occur because there is no public transport trip option that would be faster than walking for the given origin-destination pair you queried.

</details>




--------------------------------------------------------------------------------
Vignette: fare_structure.Rmd

---
title: 'Accounting for monetary costs'
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
abstract: "This vignette shows how to configure and use custom fare rules in order to account for monetary travel costs when generating travel time matrices and accessibility estimates with the `r5r` package."
urlcolor: blue
vignette: >
  %\VignetteIndexEntry{Accounting for monetary costs} 
  %\VignetteEngine{knitr::rmarkdown} 
  \usepackage[utf8]{inputenc}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  eval = identical(tolower(Sys.getenv("NOT_CRAN")), "true"),
  out.width = "100%"
)
```

# 1. Introduction

Considering the monetary costs of public transport trips in the calculation of 
travel time matrices and accessibility estimates is a major challenge faced by 
researchers and planning practitioners. Each public transport system can have 
its own set of rules for calculating fares, with varying levels of complexity. 
Moreover, there are important trade offs between travel time and monetary costs 
across multiple trip alternatives and are currently not captured by any 
multimodal routing engine, except for R5.

R5 has native capabilities and an open architecture for creating and including 
fare structures in routing models, making it possible to estimate travel time 
matrices and accessibility estimates simultaneously considering different 
combinations of time and monetary cost cutoffs. The main challenge, however, is 
that a specific fare structure for each city needs to be programmed in Java and 
tightly integrated into R5, making this functionality out of reach for those who 
do not know how to code in Java (i.e. most of us!).

To help tackle this challenge, `r5r` has a simple generic rule-based fare 
structure that can be configured via a predefined set of properties and rules 
that can be set directly from R or using external tools such as text editors and
spreadsheets. This approach currently available in `r5r` is able to account for 
the monetary costs of public transport systems that follow a simple set of fare 
rules according to which the cost of a journey depends on combinations of modes 
(see details below).

**This vignette shows the features of `r5r`s fare structure. It also uses a 
reproducible example to demonstrate how to configure the fare structure to 
account for monetary costs when generating travel time matrices and accessibility 
estimates with `r5r`**. 



## 1.1 Details

A common feature among many public transport services is the possibility of 
discounted transfers, when passengers can use a single ticket for a trip composed 
of multiple rides sometimes combining different transport modes. Such trips usually 
come with a discount in the second or subsequent fares, as well as a limit on the 
number of discounted transfers the user can make and/or a time limit for using that 
discount. This is the type of fare structure currently covered by `r5r`.

We acknowledge that there are several types fare rules that vary from one public 
transport system to another. According to these rules, the cost of a journey can 
differ, for example, depending on: different costs for each trip leg, transport 
mode or route; distance- or zone-based fares; different fares for types of riders 
(e.g elderly people or students) or time of the day (e.g. peak and off-peak hours); 
among many others rules. As such, taking all of these possible rules into 
consideration when calculating the monetary cost of multimodal can be quite 
difficult. `r5r` currently does not cover these more complex fare rules.

The fare calculator currently available in `r5r` is not intended to be a robust 
solution that can take into consideration all public transport systems and their 
specific fare rules. That would be a Herculean task. The features included in 
`r5r`'s fare calculator are inspired by our empirical observations of Brazilian 
public transport systems, and is meant to be used mainly in the [Access to Opportunities project](https://www.ipea.gov.br/acessooportunidades/en/). Everyone else is 
welcome to use it, if the current features suit their needs.

obs. The GTFS format has some features for specifying public transport fares, but
those features are quite limited and are not enough for adequately representing 
many use cases. A new version of that specification is currently being developed 
[Fares V2](https://github.com/google/transit/issues/252), but it may take some 
time for it to be approved and for transport agencies actually start providing 
GTFS feeds with full fare information.

<br>

# 2. Reprex: the public transport system of Porto Alegre

In this vignette, we will be using the sample data set for the city of Porto 
Alegre (Brazil) included in `r5r`.  Before we start, we need to increase the memory available to Java and load the packages used in this vignette

```{r, message = FALSE}
options(java.parameters = "-Xmx2G")

library(r5r)
library(sf)
library(data.table)
library(ggplot2)
library(patchwork)
library(dplyr)
library(h3jsr)
```

Porto Alegre has a relatively straightforward public transport system, where the vast majority of the population that rely on transit ride buses. The city also has a metropolitan rail service that connects the city center to the neighboring northbound municipalities. That system can be seen in the map below.

```{r}
# setup and load Porto Alegre multimodal network into memory

# system.file returns the directory with example data inside the r5r package
# set data path to directory containing your own data if not using the examples
data_path <- system.file("extdata/poa", package = "r5r")

r5r_core <- setup_r5(data_path)

# load transit network as an SF
transit_network <- transit_network_to_sf(r5r_core)

# map
ggplot() +
  geom_sf(data=transit_network$routes, aes(color=mode)) +
  theme_void()
```

According to the fare rules in Porto Alegre, as in most Brazilian cities, the 
cost a a journey depends on a combination of number of subsequent trips and/or 
transport modes. In the case of Porto Alegre, the fare rules are as follows:

-   Each bus ticket costs R\$ 4.80.
-   Riding a second bus adds R\$ 2.40 to the total cost. Subsequent bus rides cost the full ticket price of R\$ 4.80.
-   Each train ticket costs R\$ 4.50. Once a passenger enters a train station, she can take an unlimited amount of train trips as long as she doesn't leave a station.
-   The integrated fare between bus and train has a 10% discount, which totals R\$ 8.37.

In the following sections, we will demonstrate how to implement those rules within r5r's fare calculator.

<br>

# 3. Setting up the fare structure

There are three support functions in `r5r` to help users configure the fare structure:

-   `setup_fare_structure()` analyses the study area's GTFS and builds a 'skeleton' fare structure structure with the parameters that need to be set;
-   `write_fare_structure()` and `read_fare_structure()` allow saving the current fare structure settings to disk, and reading them back into memory. The settings are saved as standard `.csv` files inside a zipped folder. These files can be edited outside the R session using external text editors and spreadsheet software, for user's convenience.

First, we need to call `setup_fare_structure()`, providing three parameters: the
current `r5r_core` object, a `base_fare` used to populate the fare structure, and
the `by` parameters that identifies what is the main property of the route that 
defines the different fares.

In the example below, the `base_fare` is the standard bus ticket price of R\$ 4.80. 
We are also stating that `by = "MODE"`, so that each transport mode has its own 
fares and integration rules. Users can also create a fare structure where fare 
rules of routes differ by `"AGENCY_ID"` or `"AGENCY_NAME"`, or simply set `by = "GENERIC"` when the entire system follows the same rules.

```{r}
fare_structure <- setup_fare_structure(r5r_core, 
                                       base_fare = 4.8,
                                       by = "MODE")
```


Now let's check the contents of the `fare_structure` object. We can see below that it is simply a `list` with a few properties and data.frames.

```{r}
head(fare_structure, n=7)

```

## 3.1 Global Properties

Let's configure the global properties first, which are the ones that are applied 
to the entire system. 

### `max_discounted_transfers`
Note that `max_discounted_transfers` is set to 1 by default. This means that the 
passenger gets a fare discount in the first transfer between buses, but she would 
pay the full fare price in subsequent transfers. 

### `transfer_time_allowance`
By default, `transfer_time_allowance` is set to 120 minutes. We have to set it to 
60 minutes to fit our use case (passengers have 60 minutes to take the second bus 
on a discounted fare, otherwise a full fare is charged).

### `fare_cap`
Finally, the `fare_cap` setting indicates if there is a maximum value that can be 
charged in a trip, beyond which all subsequent rides are free of charge. In this 
example, we can leave `fare_cap` set to its default `Inf` value because this 
feature is not applicable to Porto Alegre.

Here is how we can check or update the values of these components:
```{r}
fare_structure$max_discounted_transfers
fare_structure$transfer_time_allowance <- 60 # update transfer_time_allowance
fare_structure$fare_cap
```

## 3.2 Configure fares by transport mode

To configure mode-, transfer-, and route-specific properties, we can use the three `data.frames` inside our `fare_structure` list. Let's configure the modes first. 
Below, we can see that the `fares_per_type` data.frame contains five columns:

-   `mode`: the transport mode to which rules on each row refer to;
-   `unlimited_transfers`: a logical value `TRUE` or `FALSE` that indicates if that transport mode allows unlimited transfers between trips of the same mode, such as a metro/subway system where the passenger pays a fare to access a station and then can use as many services as she wants as long as she doesn't exit the system;
-   `allow_same_route_transfer`: a logical value indicating if a discounted transfer can be done between vehicles ??? of the same route;
-   `use_route_fare`: another logical value that indicates if each route will have its own fare, or if all routes in this mode will use the fare indicated in this table;
-   `fare`: the full fare price of this mode.

```{r}
fare_structure$fares_per_type
```

We need to do a few small changes in the `fares_per_type` table to accomodate the
fare rules of Porto Alegre. In the `"RAIL"` mode, we need to set `unlimited_transfers`
and `allow_same_route_transfer` to `TRUE`, and update `fare` to 4.50. In the `"BUS"` 
mode, we can let the `allow_same_route_transfer` set to its default `FALSE` value, 
because even though there is a discount for transfers between buses (which is set 
in the following section), that discount is not valid when transferring between 
buses within the same route (for example, from bus route T1 to another T1). We'll 
do those changes below, using `data.table` notation.

```{r}
fare_structure$fares_per_type[type == "RAIL", unlimited_transfers := TRUE]
fare_structure$fares_per_type[type == "RAIL", fare := 4.50]
fare_structure$fares_per_type[type == "RAIL", allow_same_route_transfer := TRUE]
```

Checking the results below, everything looks OK:

```{r}
fare_structure$fares_per_type
```

## 3.3 Configure fares by transfers

The fare rules for transfer are stored in the `fares_per_transfer` data.frame, 
which is shown below. Each row contains the fare prices for transfers between the
modes specified in `first_leg` and `second_leg` columns.

```{r}
fare_structure$fares_per_transfer
```

Let's update `fare_per_transfer` to account for the actual integration rules in 
Porto Alegre.

-   The fare for "BUS" to "BUS" integration is composed of 4.80 for the first leg plus 2.40 for the second leg, which equals to a total fare of 7.20.

```{r}
# conditional update fare value
fare_structure$fares_per_transfer[first_leg == "BUS" & second_leg == "BUS", fare := 7.2]
```

- Transfers between "BUS" and "RAIL" (in any direction) cost 8.37, once the 10% discount is applied. Let's make a final update in the data.frame to account for that.

```{r}
# conditional update fare value
fare_structure$fares_per_transfer[first_leg != second_leg, fare := 8.37]

# use fcase instead ?
fare_structure$fares_per_transfer[, fare := fcase(first_leg == "BUS" & second_leg == "BUS", 7.2,
                                                 first_leg != second_leg, 8.37)]

```

- Transfers between "RAIL" and "RAIL" are free and unlimited, which is already 
accounted for in the field `unlimited_transfers` of the `fare_per_mode` table. 
Thus, the equivalent row of the `fare_per_transfer` data.frame needs to be removed. 
If we leave the that row in `fare_per_transfer`, transfers between "RAIL" and "RAIL" 
will count to the global `max_discounted_transfers` allowance.

```{r}
# remove row
fare_structure$fares_per_transfer <- fare_structure$fares_per_transfer[!(first_leg == "RAIL" & second_leg == "RAIL")]

```


Once all changes are applied, the `fare_per_transfer` data.frame should look like 
this:

```{r}
fare_structure$fares_per_transfer
```

## 3.4 Routes configuration

The information on the fare price for each route is stored in the `fares_per_route` 
data.frame. Below, we can see a sample of the bus and train routes in Porto Alegre. 
In case there a few special routes (e.g. express services) with specific fares, 
these values can be updated in this `fares_per_route` data.frame.



```{r}
tail(fare_structure$fares_per_route)
```

Basic route information is taken directly from the GTFS data (agency, route id 
and names, mode, etc), but the `route_fare` and `fare_type` columns were added 
specifically for the `r5r` fare structure.

-   `route_fare`: is used to set a specific fare for each route. This field can 
be used to represent services that have many unique fares, such as metropolitan 
/ suburban trains and buses. This is used together with the `use_route_fare` 
column in the `fares_per_type` table: the `route_fare` field is only considered 
by the `r5r` fare structure when `use_route_fare` of that mode is set to `TRUE`.

-   `fare_type`: is used to link each route with information in the `fares_per_type` 
and `fares_per_transfer` tables. In this example, `fare_type` is always the same 
as `mode`, because that was what we chose in the `by` parameter when calling `setup_fare_structure` earlier (we could have chosen to discriminate fares by 
agency, for example).

We actually don't have any change do to in the `fares_per_route` table, in this 
example. It does not matter that the `route_fare` value is wrong for the "RAIL" 
lines, because we are using the fares set in `fares_per_type` and `fares_per_transfer` 
which we already set up correctly before.

Now that our `fare_structure` is complete, we can use it to calculate travel time 
matrices and accessibility while accounting for monetary cost cutoffs. Let's see 
how it's done in the next sections.


# 4. Calculating travel time and accessibiilty accounting for monetary costs

The `travel_time_matrix()` and `accessibility()` functions have two new parameters 
to account for monetary costs thresholds:

-   `fare_structure`: the settings object that we've been working on.
-   `max_fare`: the maximum total fare that can be used in the trip.


## 4.1 Travel time with monetary cost

The following example shows travel time differences when monetary costs are 
accounted for, using the `travel_time_matrix()` function.


```{r}
## load input data
points <- read.csv(system.file("extdata/poa/poa_hexgrid.csv", package = "r5r"))

# calculate travel times function
calculate_travel_times <- function(fare) {
  ttm_df <- travel_time_matrix(
    r5r_core,
    origins = points,
    destinations = points,
    mode = c("WALK", "TRANSIT"),
    departure_datetime = as.POSIXct(
      "13-05-2019 14:00:00",
      format = "%d-%m-%Y %H:%M:%S"
    ),
    time_window = 1,
    fare_structure = fare_structure,
    max_fare = fare,
    max_trip_duration = 40,
    max_walk_time = 20
  )

  return(ttm_df)
}


# calculate travel times, and combine results
ttm <- calculate_travel_times(fare = Inf)
ttm_500 <- calculate_travel_times(fare = 5)

# merge results
ttm[ttm_500, on = .(from_id, to_id), travel_time_500 := i.travel_time_p50]
ttm[, travel_time_unl := travel_time_p50]
ttm[, travel_time_p50 := NULL]
```

Below, we can see a sample of the travel time differences with and without monetary 
cost restriction. We can see that some trips are not affected at all (`travel_time_unl == travel_time_500`), some trips take a little longer to complete (`travel_time_500 > travel_time_unl`), and other trips cannot be completed at all (`travel_time_500 == NA`).

```{r}
tail(ttm, 10)
```

The plots below show the overall distribution of the travel time differences and 
unreachable destinations:

```{r}
# plot of overall travel time differences between limited and unlimited cost travel time matrices 
time_difference = ttm[!is.na(travel_time_500), .(count = .N), 
                      by = .(travel_time_unl, travel_time_500)]

p1 <- ggplot(time_difference, aes(y = travel_time_unl, x = travel_time_500)) +
  geom_point(size = 0.7) +
  coord_fixed() +
  scale_x_continuous(breaks = seq(0, 45, 5)) +
  scale_y_continuous(breaks = seq(0, 45, 5)) +
  theme_light() +
  theme(legend.position = "none") +
  labs(y = "travel time (minutes)\nunestricted monetary cost",
       x = "travel time (minutes)\nmonetary cost restricted to BRL 5.00"
       )

# plot of unreachable destinations when the monetary cost limit is too low
unreachable <- ttm[, .(count = .N), by = .(travel_time_unl, is.na(travel_time_500))]
unreachable[, perc := count / sum(count, na.rm = T), by = .(travel_time_unl)]
unreachable <- unreachable[is.na == TRUE]
unreachable <- na.omit(unreachable)

p2 <- ggplot(unreachable, aes(x=travel_time_unl, y=perc)) +
  geom_col() +
  coord_flip() +
  scale_x_continuous(breaks = seq(0, 45, 5)) +
  scale_y_continuous(limits = c(0, 1), breaks = seq(0, 1, 0.2), 
                     labels = paste0(seq(0, 100, 20), "%")) +
  theme_light() +
  labs(x = "travel time (minutes)\nwithout monetary cost restriction",
       y = "% of unreachable destinations\nconsidering a R$ 5.00 monetary cost limit")

# combine both plots using patchwork
p1 + p2 + plot_annotation(subtitle = "Comparing travel times with and without monetary cost restriction")

```



## 4.2 Calculating accessibility with monetary cost

Now, we can answer questions like "how many health care facilities one can access 
in 60 minutes using public transport, on a R\$5.00 budget?". We'll do that below, 
and compare the results the accessibility unconstrained by monetary costs: 

```{r}
# calculate accessibility function
calculate_accessibility <- function(fare, fare_string) {
  access_df <- accessibility(
    r5r_core,
    origins = points,
    destinations = points,
    mode = c("WALK", "TRANSIT"),
    departure_datetime = as.POSIXct(
      "13-05-2019 14:00:00",
      format = "%d-%m-%Y %H:%M:%S"
    ),
    time_window = 1,
    opportunities_colname = "healthcare",
    cutoffs = 40,
    fare_structure = fare_structure,
    max_fare = fare,
    max_trip_duration = 40,
    max_walk_time = 20,
    progress = FALSE)

  access_df$max_fare <- fare_string

  return(access_df)
}

# calculate accessibility, combine results, and convert to SF
access_500 <- calculate_accessibility(fare=5, fare_string="R$ 5.00 budget")
access_unl <- calculate_accessibility(fare=Inf, fare_string="Unlimited budget")

access <- rbind(access_500, access_unl)

# bring geometry
access$geometry <- h3jsr::cell_to_polygon(access$id)
access <- st_as_sf(access)

```

Finally, we can plot the results and see how accessibility levels can differ 
quite substantially when we account for monetary costs. 

```{r}
# plot accessibility maps
ggplot(data = access) +
  geom_sf(aes(fill = accessibility), color=NA, size = 0.2) +
  scale_fill_distiller(palette = "Spectral") +
  facet_wrap(~max_fare) +
  labs(subtitle = "Effect of monetary cost on accessibility") +
  theme_minimal() +
  theme(legend.position = "bottom",
        axis.text = element_blank())

```


### Cleaning up after usage

`r5r` objects are still allocated to any amount of memory previously set after they are done with their calculations. In order to remove an existing `r5r` object and reallocate the memory it had been using, we use the `stop_r5` function followed by a call to Java's garbage collector, as follows:

```{r, message = FALSE}
r5r::stop_r5(r5r_core)
rJava::.jgc(R.gc = TRUE)
```

If you have any suggestions or want to report an error, please visit [the package GitHub page](https://github.com/ipeaGIT/r5r).




--------------------------------------------------------------------------------
Vignette: isochrones.Rmd

---
title: 'Isochrones'
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
abstract: "This vignette shows how to calculate and visualize isochrones in R using the `r5r` package."
urlcolor: blue
vignette: >
  %\VignetteIndexEntry{Isochrones} 
  %\VignetteEngine{knitr::rmarkdown} 
  \usepackage[utf8]{inputenc}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  eval = identical(tolower(Sys.getenv("NOT_CRAN")), "true"),
  out.width = "100%"
)
```

# 1. Introduction

An isochrone map shows how far one can travel from a given place within a certain amount of time. In other other words, it shows all the areas reachable from that place within a maximum travel time. This vignette shows how to calculate and visualize isochrones in R using the [`r5r` package](https://ipeagit.github.io/r5r/index.html) using a reproducible example. In this example, we will be using a sample data set for the city of Porto Alegre (Brazil) included in `r5r`. Our aim here is to calculate several isochrones departing from the central bus station given different travel time thresholds. 

There are two ways to calculate / visualize isochrones using `r5r`. The quick and easy option is using the `r5r::isochrone()` function. The other alternative requires one to first calculate travel time estimates, and then to do some spatial interpolation operations. We will cover both approaches in this vignette. 

Before we start, we need to increase Java memory + load a few libraries, and to build routable transport network.



***Warning:*** If you want to calculate how many opportunities (e.g. jobs, or schools or hospitals) are located inside each isochrone, we strongly recommend you NOT to use the `isochrone()` function. You will find much more efficient ways to do this in the [Accessibility vignette](https://ipeagit.github.io/r5r/articles/accessibility.html).


# 2. Build routable transport network with `setup_r5()`

### Increase Java memory and load libraries

First, we need to increase the memory available to Java and load the packages used in this vignette. Please note we allocate RAM memory to Java *before* loading our libraries.

```{r, message = FALSE}
options(java.parameters = "-Xmx2G")

library(r5r)
library(sf)
library(data.table)
library(ggplot2)
library(interp)
```


To build a routable transport network with `r5r`, the user needs to call `setup_r5()` with the path to the directory where OpenStreetMap and GTFS data are stored.

```{r, message = FALSE}
# system.file returns the directory with example data inside the r5r package
# set data path to directory containing your own data if not running this example
data_path <- system.file("extdata/poa", package = "r5r")

r5r_core <- setup_r5(data_path)
```


# 3. Isochrone: quick and easy approach

The quick and easy approach to estimate / visualize an isochrone is to use the `isochrone()` function built in the `r5r` package. In this example, we will be calculating the isochrones by public transport from the central bus station in Porto Alegre. The `isochrone()` function calculates isochrones considering the travel times from the origin point to a random sample of `80%` of all nodes in the transport network (default). The size of the sample can be fine tuned with the `sample_size` parameter. 

With the code below, `r5r` determines the isochrones considering the median travel time of multiple travel time estimates calculated departing every minute over a 120-minute time window, between 2pm and 4pm.



```{r, message = FALSE}
# read all points in the city
points <- fread(file.path(data_path, "poa_hexgrid.csv"))

# subset point with the geolocation of the central bus station
central_bus_stn <- points[291,]

# isochrone intervals
time_intervals <- seq(0, 100, 10)

# routing inputs
mode <- c("WALK", "TRANSIT")
max_walk_time <- 30      # in minutes
max_trip_duration <- 100 # in minutes
time_window <- 120       # in minutes
departure_datetime <- as.POSIXct("13-05-2019 14:00:00",
                                 format = "%d-%m-%Y %H:%M:%S")

# calculate travel time matrix
iso1 <- r5r::isochrone(r5r_core,
                       origins = central_bus_stn,
                       mode = mode,
                       cutoffs = time_intervals,
                       sample_size = 1,
                       departure_datetime = departure_datetime,
                       max_walk_time = max_walk_time,
                       max_trip_duration = max_trip_duration,
                       time_window = time_window,
                       progress = FALSE)

```
As you can see, the `isochrone()` functions works very similarly to the `travel_time_matrix()` function, but instead of returning a table with travel time estimates, it returns a `POLYGON  "sf" "data.frame"` for each isochrone of each origin.

```{r, message = FALSE}
head(iso1)
```

Now it becomes super simple to visualize our isochrones on a map:

```{r, message = FALSE}
# extract OSM network
street_net <- street_network_to_sf(r5r_core)
main_roads <- subset(street_net$edges, street_class %like% 'PRIMARY|SECONDARY')
  
colors <- c('#ffe0a5','#ffcb69','#ffa600','#ff7c43','#f95d6a',
            '#d45087','#a05195','#665191','#2f4b7c','#003f5c')

ggplot() +
  geom_sf(data = iso1, aes(fill=factor(isochrone)), color = NA, alpha = .7) +
  geom_sf(data = main_roads, color = "gray55", size=0.01, alpha = 0.2) +
  geom_point(data = central_bus_stn, aes(x=lon, y=lat, color='Central bus\nstation')) +
  # scale_fill_viridis_d(direction = -1, option = 'B') +
  scale_fill_manual(values = rev(colors) ) +
  scale_color_manual(values=c('Central bus\nstation'='black')) +
  labs(fill = "Travel time\n(in minutes)", color='') +
  theme_minimal() +
  theme(axis.title = element_blank())
```


# 4 Isochrone alternative

This second approach to calculating isochrones with `r5r` takes a few more steps because it requires the spatial interpolation of travel time estimates, but it generates more refined maps. It takes two steps. 

# 4.1 Calculate travel times

First, we calculate the travel times by public transport from the central bus station in Porto Alegre to multiple destinations we input to the function. Here, we input the `points` data frame, which comprises the centroids of a hexagonal grid at a fine spatial resolution.

```{r, message = FALSE}
# calculate travel time matrix
ttm <- travel_time_matrix(r5r_core,
                          origins = central_bus_stn,
                          destinations = points,
                          mode = mode,
                          departure_datetime = departure_datetime,
                          max_walk_time = max_walk_time,
                          max_trip_duration = max_trip_duration,
                          time_window = time_window,
                          progress = FALSE)

head(ttm)

```

# 4.2 Spatial interpolation of travel times

Now we need to bring the spatial coordinates information to our travel time matrix output `ttm`, and do some spatial interpolation of travel time estimates.

```{r, message = FALSE}
# add coordinates of destinations to travel time matrix
ttm[points, on=c('to_id' ='id'), `:=`(lon = i.lon, lat = i.lat)]

# interpolate estimates to get spatially smooth result
travel_times.interp <- with(na.omit(ttm), interp(lon, lat, travel_time_p50)) |>
                        with(cbind(travel_time=as.vector(z),  # Column-major order
                                   x=rep(x, times=length(y)),
                                   y=rep(y, each=length(x)))) |>
                            as.data.frame() |> na.omit()
```


With just a few more lines of code, we get our isochrones on a map:

```{r, message = FALSE, out.width='100%'}
# find isochrone's bounding box to crop the map below
bb_x <- c(min(travel_times.interp$x), max(travel_times.interp$x))
bb_y <- c(min(travel_times.interp$y), max(travel_times.interp$y))

# plot
ggplot(travel_times.interp) +
  geom_sf(data = main_roads, color = "gray55", size=0.01, alpha = 0.7) +
  geom_contour_filled(aes(x=x, y=y, z=travel_time), alpha=.7) +
  geom_point(aes(x=lon, y=lat, color='Central bus\nstation'),
             data=central_bus_stn) +
  # scale_fill_viridis_d(direction = -1, option = 'B') +
  scale_fill_manual(values = rev(colors) ) +
  scale_color_manual(values=c('Central bus\nstation'='black')) +
  scale_x_continuous(expand=c(0,0)) +
  scale_y_continuous(expand=c(0,0)) +
  coord_sf(xlim = bb_x, ylim = bb_y) +
  labs(fill = "Travel time\n(in minutes)", color='') +
  theme_minimal() +
  theme(axis.title = element_blank())
```


### Cleaning up after usage

`r5r` objects are still allocated to any amount of memory previously set after they are done with their calculations. In order to remove an existing `r5r` object and reallocate the memory it had been using, we use the `stop_r5` function followed by a call to Java's garbage collector, as follows:

```{r, message = FALSE}
r5r::stop_r5(r5r_core)
rJava::.jgc(R.gc = TRUE)
```

If you have any suggestions or want to report an error, please visit [the package GitHub page](https://github.com/ipeaGIT/r5r).



--------------------------------------------------------------------------------
Vignette: pareto_frontier.Rmd

---
title: 'Trade-offs between travel time and monetary cost'
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
abstract: "This vignette shows how to use the `pareto_frontier()` function to examine the trade-offs between travel time and monetary cost in travel time matrices in r5r."
urlcolor: blue
vignette: >
  %\VignetteIndexEntry{Trade-offs between travel time and monetary cost} 
  %\VignetteEngine{knitr::rmarkdown} 
  \usepackage[utf8]{inputenc}
bibliography: references.json
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  eval = identical(tolower(Sys.getenv("NOT_CRAN")), "true"),
  out.width = "100%"
)
```

# 1. Introduction

In most cases, transport routing models find either the fastest or the lowest-cost
routes that connect places in a given transport network. Sometimes, though, we 
might want a more sophisticated analysis that considers both the time and monetary 
costs that public transport passengers have to face. The problem here is that simultaneously accounting for both time and monetary costs is a major challenge 
for routing models because of the trade-offs between the objectives of minimizing 
trip duration and cost [@conway2019getting].

To address this problem, `r5r` has a function called `pareto_frontier()`, which calculates the most efficient route possibilities between origin destination pairs considering multiple combinations of travel time and monetary costs. This vignette 
uses a reproducible example to demonstrate how to use `pareto_frontier()` and 
interpret its results.



## 2. What the `pareto_frontier` means.

Imagine a hypothetical journey from A to B. There are multiple route alternatives 
between this origin and destination with varying combinations of travel time and 
cost (figure below).

* Walking from A to B would be the **cheapest** option but it would take 50 minutes.
* The **fastest** option would be to take a bus to a subway station and transfer to the subway. This option would only take 15 minutes, but it would cost $8.
* There are some intermediary alternatives, such as taking:
    * a single bus, $3 for 35 min.
    * two buses with one transfer, $5 for 29 min.
    * taking the subway after walking to the station , $6 for 20 min.

This figure illustrates the Pareto frontier of alternative routes from A to B. In 
other words, it shows the most optimal set of route alternatives between A and B. 
There are certainly other route options, but there is no other option that is both 
faster and cheaper at the same time.

```{r, echo = FALSE, fig.width=7, fig.height=4}
library(ggplot2)

# data.frame
df <- structure(list(option = c(1, 2, 3, 4, 5), 
                     modes = c("Walk", "Bus","Bus + Bus", "Subway", "Bus + Subway"), 
                     time = c(50, 35, 29, 20, 15), 
                     cost = c(0, 3, 5, 6, 8)), class = "data.frame", 
                row.names = c(NA, -5L))

# figure
ggplot(data=df, aes(x=cost, y=time, label = modes)) + 
  geom_step(linetype = "dashed") +
  geom_point() +
  geom_text(color='gray30', hjust = -.2, nudge_x = 0.05, angle = 45) +
  labs(title='Pareto frontier of alternative routes from A to B', subtitle = 'Hypotetical example') +
  scale_x_continuous(name="Travel cost (BRL)", breaks=seq(0,12,3)) +
  scale_y_continuous(name="Travel time (minutes)", breaks=seq(0,60,10)) +
  coord_cartesian(xlim = c(0,14), ylim = c(0, 60)) +
  theme_classic()
```

<br>

This kind of abstraction allows us to have a better grasp of the trade-offs between travel time and monetary cost passengers face when using public transport. It also 
allows us to calculate cumulative-opportunity accessibility metrics with cutoffs 
for both time and cost (e.g. the number of jobs reachable from a given origin with 
limits of 40 minutes and $5) (ref paper by Matt and Anson).

Let's see a couple concrete examples showing how `r5r` can calculate the Pareto 
frontier for multiple origins.



## 3. Demonstration of `pareto_frontier()`.

### 3.1 Build routable transport network with `setup_r5()`

First, let's build the network and create the routing inputs. In this example 
we'll be using the a sample data set for the city of Porto Alegre (Brazil) 
included in `r5r`.

```{r, message = FALSE}
# increase Java memory
options(java.parameters = "-Xmx2G")

# load libraries
library(r5r)
library(data.table)
library(ggplot2)
library(dplyr)

# build a routable transport network with r5r
data_path <- system.file("extdata/poa", package = "r5r")
r5r_core <- setup_r5(data_path)

# routing inputs
mode <- c('walk', 'transit')
max_trip_duration <- 90 # minutes

# load origin/destination points of interest
points <- fread(file.path(data_path, "poa_points_of_interest.csv"))

```


### 3.2 Set up the fare structure

Now we need to set what are the fare rules of our public transport system. These 
rules will be used by `R5` to calculate the monetary cost of alternative routes. 
In the case of Porto Alegre, the fare rules are as follows:
* Each bus ticket costs R$ 4.80.
*  Riding a second bus adds `$` 2.40 to the total cost. Subsequent bus rides cost the full ticket price of $ 4.80.
* Each train ticket costs $ 4.50. Once a passenger enters a train station, she can take an unlimited amount of train trips as long as she doesn’t leave a station.
* The integrated fare between bus and train has a 10% discount, which totals $ 8.37.

We can create `list` object with these fare rules with the support of the `setup_fare_structure()` function as shown in the code below. A detailed explanation of how to use the fare structure of `5r5` can be found in [(this other vignette)](https://ipeagit.github.io/r5r/articles/fare_structure.html).


```{r}
# create basic fare structure
fare_structure <- setup_fare_structure(r5r_core, 
                                       base_fare = 4.8,
                                       by = "MODE")

# update the cost of bus and train fares
fare_structure$fares_per_type[, fare := fcase(type == "BUS", 4.80,
                                             type == "RAIL", 4.50)]

# update the cost of tranfers
fare_structure$fares_per_transfer[, fare := fcase(first_leg == "BUS" & second_leg == "BUS", 7.2,
                                                 first_leg != second_leg, 8.37)]

# update transfer_time_allowance to 60 minutes
fare_structure$transfer_time_allowance <- 60

fare_structure$fares_per_type[type == "RAIL", unlimited_transfers := TRUE]
fare_structure$fares_per_type[type == "RAIL", allow_same_route_transfer := TRUE]

```

For convenience, we can save these fare rules as a `zip` file and load again for 
a future application.


```{r}
# save fare rules to temp file
temp_fares <- tempfile(pattern = "fares_poa", fileext = ".zip")
r5r::write_fare_structure(fare_structure, file_path = temp_fares)


fare_structure <- r5r::read_fare_structure(file.path(data_path, "fares/fares_poa.zip"))
```


### 3.3 Calculating a `pareto_frontier()`.

In this example, we calculate the Pareto frontier from all origins to all 
destinations considering multiple cutoffs of monetary costs:
- $1, which would only allow for walking trips
- $4.5, which would only allow for rail trips
- $4.8, which would allow for a single bus trip
- $7.20, which would allow for bus + bus
- $8.37, which would allow for walking walking + bus + rail

```{r}
departure_datetime <- as.POSIXct("13-05-2019 14:00:00", 
                                 format = "%d-%m-%Y %H:%M:%S")

prtf <- pareto_frontier(r5r_core,
                      origins = points,
                      destinations = points,
                      mode = c("WALK", "TRANSIT"),
                      departure_datetime = departure_datetime,
                      fare_structure = fare_structure,
                      fare_cutoffs = c(1, 4.5, 4.8, 7.20, 8.37),
                      progress = TRUE
                      )
head(prtf)

```


For the sake of illustration, let's check the optimum route alternatives from 
the Farrapos train station to (a) the Praia de Belas shopping mall and (b) the 
Moinhos hospital. An optimum route alternative means that one cannot make a faster trip without 
increasing costs, and one cannot make a cheaper trip without increasing travel time.


```{r, echo = FALSE, fig.width=7, fig.height=4}
# select origin and destinations
pf2 <- dplyr::filter(prtf, to_id == 'farrapos_station'  &
                       from_id %in% c('moinhos_de_vento_hospital', 
                                      'praia_de_belas_shopping_center'))

# recode modes
pf2[, modes := fcase(monetary_cost == 1,   'Walk',
                     monetary_cost == 4.5, 'Train',
                     monetary_cost == 4.8, 'Bus',
                     monetary_cost == 7.2, 'Bus + Bus',
                     monetary_cost == 8.37, 'Bus + Train')]

# plot
ggplot(data=pf2, aes(x=monetary_cost, y=travel_time, color=from_id, label = modes)) + 
  geom_step(linetype = "dashed") +
  geom_point() +
  geom_text(color='gray30', hjust = -.2, nudge_x = 0.05, angle = 45) +
  labs(title='Pareto frontier of alternative routes from Farrapos station to:', 
       subtitle = 'Praia de Belas shopping mall and Moinhos hospital',
       color='Destination') +
  scale_x_continuous(name="Travel cost ($)", breaks=seq(0,12,2)) +
  scale_y_continuous(name="Travel time (minutes)", breaks=seq(0,120,20)) +
  coord_cartesian(xlim = c(0,12), ylim = c(0, 120)) +
  theme_classic() + theme(legend.position=c(.2,0.8))
```

### Cleaning up after usage

`r5r` objects are still allocated to any amount of memory previously set after they are done with their calculations. In order to remove an existing `r5r` object and reallocate the memory it had been using, we use the `stop_r5` function followed by a call to Java's garbage collector, as follows:

```{r, message = FALSE}
r5r::stop_r5(r5r_core)
rJava::.jgc(R.gc = TRUE)
```

If you have any suggestions or want to report an error, please visit [the package GitHub page](https://github.com/ipeaGIT/r5r).


## References



--------------------------------------------------------------------------------
Vignette: r5r.Rmd

---
title: 'Intro to r5r: Rapid Realistic Routing with R5 in R'
author: "Rafael H. M. Pereira, Marcus Saraiva, Daniel Herszenhut, Carlos Kaue Braga"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
abstract: "`{r5r}` is an R package for rapid realistic routing on multimodal transport networks (walk, bike, public transport and car) using R<sup>5</sup>. The package allows users to generate detailed routing analysis or calculate travel time matrices using seamless parallel computing on top of the R<sup>5</sup> Java machine <https://github.com/conveyal/r5>"
urlcolor: blue
vignette: >
  %\VignetteIndexEntry{Intro to r5r: Rapid Realistic Routing with R5 in R} 
  %\VignetteEngine{knitr::rmarkdown} 
  \usepackage[utf8]{inputenc}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  eval = identical(tolower(Sys.getenv("NOT_CRAN")), "true"),
  out.width = "100%"
)

## removes files previously created by 'setup_r5()'
#data_path <- system.file("extdata/poa", package = "r5r")
#existing_files <- list.files(data_path)
#files_to_keep <- c(
#  "poa_hexgrid.csv",
#  "poa_osm.pbf",
#  "poa_points_of_interest.csv",
#  "poa_eptc.zip",
#  "poa_trensurb.zip",
#  'fares'
#  )
#files_to_remove <- existing_files[! existing_files %in% files_to_keep]
#invisible(file.remove(file.path(data_path, files_to_remove)))
```

# 1. Introduction 

**r5r** is an [R package for rapid realistic routing on multimodal transport networks](https://github.com/ipeaGIT/r5r) (walk, bike, public transport and car). It provides a simple and friendly interface to R<sup>5</sup>, a really fast and open source Java-based routing engine developed separately by [Conveyal](https://www.conveyal.com/). R<sup>5</sup> stands for [Rapid Realistic Routing on Real-world and Reimagined networks](https://github.com/conveyal/r5). More details about **r5r** can be found on the [package webpage](https://ipeagit.github.io/r5r/index.html) or on this [paper](
https://doi.org/10.32866/001c.21262).

# 2. Installation

You can install `{r5r}` from CRAN, or the development version from github.

```{r, eval = FALSE}
# from CRAN
install.packages('r5r')

# dev version with latest features
devtools::install_github("ipeaGIT/r5r", subdir = "r-package")
```


Please bear in mind that you need to have *Java Development Kit (JDK) 21* installed 
on your computer to use `{r5r}`. No worries, you don't have to pay for it. There are
numerous open-source JDK implementations, and you only need to install one JDK. Here are a few options:

- [Adoptium/Eclipse Temurin](https://adoptium.net/) (our preferred option)
- [Amazon Corretto](https://aws.amazon.com/corretto/)
- [Oracle OpenJDK](https://jdk.java.net/21/). 

The easiest way to install JDK is using the new [{rJavaEnv}](https://www.ekotov.pro/rJavaEnv/) package in R:

```{r, eval = FALSE}
# install {rJavaEnv} from CRAN
install.packages("rJavaEnv")

# check version of Java currently installed (if any) 
rJavaEnv::java_check_version_rjava()

## if this is the first time you use {rJavaEnv}, you might need to run this code
## below to consent the installation of Java.
# rJavaEnv::rje_consent(provided = TRUE)

# install Java 21
rJavaEnv::java_quick_install(version = 21)

# check if Java was successfully installed
rJavaEnv::java_check_version_rjava()

```


# 3. Usage

First, we need to increase the memory available to Java. This has to be done **before** loading the `{r5r}` library because, by default, `R` allocates only 512MB of memory for Java processes, which is not enough for large queries using `{r5r}`. To increase available memory to 2GB, for example, we need to set the `java.parameters` option at the beginning of the script, as follows:

```{r, message = FALSE}
options(java.parameters = "-Xmx2G")

# By default, {r5r} uses all CPU cores available. If you want to limit the 
# number of CPUs to 4, for example, you can run:  
options(java.parameters = c("-Xmx2G", "-XX:ActiveProcessorCount=4"))
```

Note: It's very important to allocate enough memory before loading `{r5r}` or any other Java-based package, since `rJava` starts a Java Virtual Machine only once for each R session. It might be useful to restart your R session and execute the code above right after, if you notice that you haven't succeeded in your previous attempts. 

Then we can load the packages used in this vignette:

```{r, message = FALSE, warning = FALSE}
library(r5r)
library(sf)
library(data.table)
library(ggplot2)
```

The `{r5r}` package has seven **fundamental functions**:

1. `setup_r5()` to initialize an instance of `{r5r}`, that also builds a routable
transport network;

2. `accessibility()` for fast computation of access to opportunities considering
a selected decay function;

3. `travel_time_matrix()` for fast computation of travel time estimates between origin/destination pairs;

4. `expanded_travel_time_matrix()` for calculating travel matrices between origin destination pairs with additional information such as routes used and total time disaggregated by access, waiting, in-vehicle and transfer times.

5. `detailed_itineraries()` to get detailed information on one or multiple alternative routes between origin/destination pairs.

6. `pareto_frontier()` for analyzing the trade-off between the travel time and monetary costs of multiple route alternatives between origin/destination pairs.

7. `isochrone()` to estimate the polygons of the areas that can be reached from an origin point at different travel time limits.

Most of these functions also allow users to account for monetary travel costs 
when generating travel time matrices and accessibility estimates. More info about
how to consider monetary costs can be found in [this vignette](https://ipeagit.github.io/r5r/articles/fare_structure.html).


The package also includes a few **support functions**.

1. `street_network_to_sf()` to extract OpenStreetMap network in sf format from a `network.dat` file.

2. `transit_network_to_sf()` to extract transit network in sf format from a `network.dat` file.

3. `find_snap()` to find snapped locations of input points on street network.

4. `r5r_sitrep()` to generate a situation report to help debug eventual errors.

## 3.1 Data requirements:

To use `{r5r}`, you will need:

- A road network data set from OpenStreetMap in `.pbf` format (*mandatory*)
- A public transport feed in `GTFS.zip` format (optional)
- A raster file of Digital Elevation Model data in `.tif` format (optional)

Here are a few places from where you can download these data sets:

- OpenStreetMap
  - [osmextract](https://docs.ropensci.org/osmextract/) R package
  - [geofabrik](https://download.geofabrik.de/) website
  - [hot export tool](https://export.hotosm.org/) website
  - [BBBike.org](https://extract.bbbike.org/) website

- GTFS
  - [tidytransit](https://r-transit.github.io/tidytransit/) R package
  - [transitland](https://www.transit.land/) website
  - [Mobility Database](https://database.mobilitydata.org/) website

- Elevation
  - [elevatr](https://github.com/USEPA/elevatr) R package
  - Nasa's SRTMGL1 website


Let's have a quick look at how `{r5r}` works using a sample data set.



# 4. Demonstration on sample data

## Data

To illustrate the functionalities of `{r5r}`, the package includes a small sample data for the city of Porto Alegre (Brazil). It includes seven files:

* An OpenStreetMap network: `poa_osm.pbf`
* Two public transport feeds: `poa_eptc.zip` and `poa_trensurb.zip`
* A raster elevation data: `poa_elevation.tif`
* A `poa_hexgrid.csv` file with spatial coordinates of a regular hexagonal grid covering the sample area, which can be used as origin/destination pairs in a travel time matrix calculation.
* A `poa_points_of_interest.csv` file containing the names and spatial coordinates of 15 places within Porto Alegre
* A `fares_poa.zip` file with the fare rules of the city's public transport system.


```{r}
data_path <- system.file("extdata/poa", package = "r5r")
list.files(data_path)
```

The points of interest data can be seen below.  In this example, we will be looking at transport alternatives between some of those places.

```{r}
poi <- fread(file.path(data_path, "poa_points_of_interest.csv"))
head(poi)
```

The data with origin destination pairs is shown below. In this example, we will be using  200 points randomly selected from this data set.

```{r}
points <- fread(file.path(data_path, "poa_hexgrid.csv"))

# sample points
sampled_rows <-  sample(1:nrow(points), 200, replace=TRUE)
points <- points[ sampled_rows, ]
head(points)
```



## 4.1 Building routable transport network with `setup_r5()`

The first step is to build the multimodal transport network used for routing in R<sup>5</sup>. This is done with the `setup_r5` function. This function does two things: (1) downloads/updates a compiled JAR file of R<sup>5</sup> and stores it locally in the `{r5r}` package directory for future use; and (2) combines the osm.pbf and gtfs.zip data sets to build a routable network object.

```{r, message = FALSE}
# Indicate the path where OSM and GTFS data are stored
r5r_core <- setup_r5(data_path = data_path)
```


## 4.2 Accessibility analysis

The fastest way to calculate accessibility estimates is using the `accessibility()`
function. In this example, we calculate the number of schools and health care 
facilities accessible in less than 60 minutes by public transport and walking.
More details in this vignette on [Calculating and visualizing Accessibility](https://ipeagit.github.io/r5r/articles/accessibility.html).

```{r, message = FALSE}
# set departure datetime input
departure_datetime <- as.POSIXct("13-05-2019 14:00:00",
                                 format = "%d-%m-%Y %H:%M:%S")

# calculate accessibility
access <- accessibility(r5r_core = r5r_core,
                        origins = points,
                        destinations = points,
                        opportunities_colnames = c("schools", "healthcare"),
                        mode = c("WALK", "TRANSIT"),
                        departure_datetime = departure_datetime,
                        decay_function = "step",
                        cutoffs = 60
                        )
head(access)
```



## 4.3 Routing analysis

For fast routing analysis, **r5r** currently has three core functions: 
`travel_time_matrix()`, `expanded_travel_time_matrix()` and `detailed_itineraries()`.


### Fast many to many travel time matrix

The `travel_time_matrix()` function is a really simple and fast function to 
compute travel time estimates between one or multiple origin/destination pairs. 
The origin/destination input can be either a spatial `sf POINT` object, or a 
`data.frame` containing the columns `id, lon, lat`. The function also receives 
as inputs the *max walking distance*, in meters, and the *max trip duration*, in
minutes. Resulting travel times are also output in minutes.

This function also allows users to very efficiently capture the travel time 
uncertainties inside a given time window considering multiple departure times. 
[More info on this vignette](https://ipeagit.github.io/r5r/articles/time_window.html). 


```{r, message = FALSE}
# set inputs
mode <- c("WALK", "TRANSIT")
max_walk_time <- 30 # minutes
max_trip_duration <- 120 # minutes
departure_datetime <- as.POSIXct("13-05-2019 14:00:00",
                                 format = "%d-%m-%Y %H:%M:%S")

# calculate a travel time matrix
ttm <- travel_time_matrix(r5r_core = r5r_core,
                          origins = poi,
                          destinations = poi,
                          mode = mode,
                          departure_datetime = departure_datetime,
                          max_walk_time = max_walk_time,
                          max_trip_duration = max_trip_duration)

head(ttm)
```

```{r ttm head, echo=FALSE, message=FALSE, out.width='100%', eval = FALSE}
knitr::include_graphics("https://github.com/ipeaGIT/r5r/blob/master/r-package/inst/img/vig_output_ttm.png?raw=true")
```


### Expanded travel time matrix with minute-by-minute estimates

For those interested in more detailed outputs, the `expanded_travel_time_matrix()` 
works very similarly with `travel_time_matrix()` but it brings much more 
information. It estimates for each origin destination pair the routes used and 
total time disaggregated by access, waiting, in-vehicle and transfer times. 
Please note this  function can be very memory intensive for large data sets.


```{r, message = FALSE}
# calculate a travel time matrix
ettm <- expanded_travel_time_matrix(r5r_core = r5r_core,
                          origins = poi,
                          destinations = poi,
                          mode = mode,
                          departure_datetime = departure_datetime,
                          breakdown = TRUE,
                          max_walk_time = max_walk_time,
                          max_trip_duration = max_trip_duration)

head(ettm)
```



### Detailed itineraries

Most routing packages only return the fastest route. A key advantage of the `detailed_itineraries()` function is that is allows for fast routing analysis 
while providing multiple alternative routes between origin destination pairs. 
The output also brings detailed information for each route alternative at the 
trip segment level, including the transport mode, waiting times, travel time and
distance of each trip segment. 

In this example below, we want to know some alternative routes between one origin/destination pair only.

```{r, message = FALSE}
# set inputs
origins <- poi[10,]
destinations <- poi[12,]
mode <- c("WALK", "TRANSIT")
max_walk_time <- 60 # minutes
departure_datetime <- as.POSIXct("13-05-2019 14:00:00",
                                 format = "%d-%m-%Y %H:%M:%S")

# calculate detailed itineraries
det <- detailed_itineraries(r5r_core = r5r_core,
                            origins = origins,
                            destinations = destinations,
                            mode = mode,
                            departure_datetime = departure_datetime,
                            max_walk_time = max_walk_time,
                            shortest_path = FALSE)

head(det)
```
```{r detailed head, echo = FALSE, out.width='100%', message = FALSE, eval = FALSE}
knitr::include_graphics("https://github.com/ipeaGIT/r5r/blob/master/r-package/inst/img/vig_output_detailed.png?raw=true")
```

The output is a `data.frame sf` object, so we can easily visualize the results.

#### Visualize results

**Static visualization** with `ggplot2` package: To provide a geographic context 
for the visualization of the results in `ggplot2`, you can also use the `street_network_to_sf()` function to  extract the OSM street network used in the routing.

```{r, message = FALSE}
# extract OSM network
street_net <- street_network_to_sf(r5r_core)

# extract public transport network
transit_net <- r5r::transit_network_to_sf(r5r_core)

# plot
ggplot() +
  geom_sf(data = street_net$edges, color='gray85') +
  geom_sf(data = det, aes(color=mode)) +
  facet_wrap(.~option) + 
  theme_void()

```

```{r ggplot2 output, echo = FALSE, out.width='100%', message = FALSE, eval = FALSE}
knitr::include_graphics("https://github.com/ipeaGIT/r5r/blob/master/r-package/inst/img/vig_detailed_ggplot.png?raw=true")
```


### Cleaning up after usage

`{r5r}` objects are still allocated to any amount of memory previously set after they are done with their calculations. In order to remove an existing `{r5r}` object and reallocate the memory it had been using, we use the `stop_r5` function followed by a call to Java's garbage collector, as follows:

```{r, message = FALSE}
r5r::stop_r5(r5r_core)
rJava::.jgc(R.gc = TRUE)
```

```{r, eval = TRUE, include = FALSE, message = FALSE}
# clean cache (CRAN policy)
r5r::r5r_cache(delete_file = 'all')

```

If you have any suggestions or want to report an error, please visit [the package GitHub page](https://github.com/ipeaGIT/r5r).





--------------------------------------------------------------------------------
Vignette: time_window.Rmd

---
title: 'Using the time_window parameter'
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
abstract: "This vignette shows how to use and interpret the `time_window` parameter in r5r."
urlcolor: blue
vignette: >
  %\VignetteIndexEntry{Using the time_window parameter} 
  %\VignetteEngine{knitr::rmarkdown} 
  \usepackage[utf8]{inputenc}
bibliography: references.json
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  eval = identical(tolower(Sys.getenv("NOT_CRAN")), "true"),
  out.width = "100%"
)

```

## 1. Introduction 

### The problem
To calculate the travel time from A to B, or to calculate the accessibility level at a given location, one has to select a departure time. However, travel time and accessibility estimates can differ significantly at different departure times because of how public transport service levels vary across the day [@stepniak2019impact]. Even a small difference, say leaving at `10:00am` or `10:04am` might importantly change travel time and accessibility estimates depending on when a person departs relative to when a public transport vehicle arrives, and how well transfers are coordinated given a service timetable. This is a very common issue related to the modifiable temporal unit problem (MTUP) [@pereiramtup2019; @levinson2020manual].

This problem gets even more complicated when public transport GTFS feeds have a `frequencies.txt` table. In these cases, we cannot know the exact departure time of vehicles, what creates greater uncertainty for our travel time and accessibility estimates [@conway2018accounting; @stewart2022half].


### The solution

A common strategy to overcome this problem is to calculate travel times and accessibilities at multiple departure times sampled over a time window, and then take the average or median value. Now you may ask, but how many departure times should I use? You might also be thinking  that doing multiple repeated routing analysis can be cumbersome and take a lot of time. Right?

Here is where `r5r` comes in. Both the `travel_time_matrix()`and `accessibility()` functions have a parameter called `time_window`. When this parameter is set, R<sup>5</sup> will automatically compute multiple travel times / accessibility estimates considering multiple departures per minute within the `time_window` selected by the user.

This vignette shows a reproducible example to explain how one can use the `time_window` and interpret the results.


## 2. How the `time_window` works and how to interpret the results.

As mentioned above, when `time_window` is set, R<sup>5</sup> computes multiple travel times / accessibility estimates starting at the specified `departure_datetime` and within the `time_window` selected by the user.  By default, `r5r` will generate one estimate per minute. Nonetheless, users can set a number to the `draws_per_minute` parameter that will change the number of Monte Carlo draws to perform per time window minute. The default value of `draws_per_minute` is 5, which mean 300 draws in a 60 minutes time window, for example. For a detailed discussion on the effect of number of draws on result stability, see Stewart et al [-@stewart2022half].

In this case, there isn't a single estimate of travel time / accessibility, but a distribution of several estimates that reflect the travel time / accessibility uncertainties in the specified time window. To get our heads around so many estimates, we can use the `percentiles` parameter to specify the percentiles of the distribution we are interested in. For example, if we select the 25th travel time percentile and the results show that the travel time estimate between A and B is 15 minutes, this means that 25% of all trips taken between these points within the specified time window are shorter than 15 minutes.


Let's see a couple concrete examples now.

## 3. Demonstration of `time_window`.

### 3.1 Build routable transport network with `setup_r5()`

First, let's build the network and create the routing inputs. In this example we'll be using the a sample data set for the city of São Paulo (Brazil) included in `r5r`.


```{r, message = FALSE}
# increase Java memory
options(java.parameters = "-Xmx2G")

# load libraries
library(r5r)
library(sf)
library(data.table)
library(ggplot2)
library(dplyr)

# build a routable transport network with r5r
data_path <- system.file("extdata/spo", package = "r5r")
r5r_core <- setup_r5(data_path)

# routing inputs
mode <- c('walk', 'transit')
max_walk_time <- 30 # minutes
max_trip_duration <- 90 # minutes

# load origin/destination points
points <- fread(file.path(data_path, "spo_hexgrid.csv"))

# departure datetime
departure_datetime = as.POSIXct("13-05-2019 14:00:00", 
                                format = "%d-%m-%Y %H:%M:%S")
```

ps. Please keep in mind that the Monte Carlo draws in `time_window` only affects the results when the GTFS feeds contain a `frequencies.txt` table. If the GTFS feed does not have a frequency table, r5r still allow for multiple runs over the set `time_window` in a deterministic way.


### 3.2 Accessibility with `time_window`.

In this example we calculate the number of schools accessible from each location within a 60-minute time window departing between 2pm and 3pm. In this example we'll be using a cumulative accessibility metric `decay_function = "step"` with a max time threshold of 45 minutes `cutoffs = 45`.

```{r, message = FALSE}
# estimate accessibility
acc <- r5r::accessibility(r5r_core = r5r_core,   
                          origins = points,
                          destinations = points, 
                          opportunities_colnames = 'schools',
                          mode = mode,
                          max_walk_time = max_walk_time,
                          decay_function = "step",
                          cutoffs = 45,
                          departure_datetime = departure_datetime,
                          progress = FALSE,
                          time_window = 60,
                          percentiles = c(10, 20, 50, 70, 80)
                          )

head(acc, n = 10)

```

This output is in long format, so the first 5 rows show the result for the same origin. In this case, we see that in only 10% of the trips departing from that origin between 2pm and 3pm a person would be able to access up to 111 schools. Meanwhile, 50% of the times she would only access 79 schools. By contrast, the accessibility from the other origin shown in the output above is 0, meaning there are no schools accessible from that location given the max travel time of 45 minutes.

We can use a plot like the one below to visualize this uncertainty in how accessibility levels might vary between 2pm and 3pm depending on the departure time within that 60-minute time window.

```{r}
# summarize
df <- acc[, .(min_acc = min(accessibility),
              median = accessibility[which(percentile == 50)],
              max_acc = max(accessibility)), by = id]

# plot
ggplot(data=df) +
  geom_linerange(color='gray', alpha=.5, aes(x = reorder(id, median) , 
                      y=median, ymin=min_acc, ymax=max_acc)) +
  geom_point(color='#0570b0', size=.5, aes(x = reorder(id, median), y=median)) +
  labs(y='N. of schools accessible\nby public transport', x='Origins sorted by accessibility',
       title="Accessibility uncertainty between 2pm and 3pm",
       subtitle = 'Upper limit 10% and lower limit 80% of the times') +
  theme_classic() +
  theme(axis.text.x=element_blank(),
        axis.ticks.x=element_blank())
```



### 3.3 Travel time matrix with `time_window`.

Now let's calculate all-to-all travel time estimates within a 60-minute time window departing between 2pm and 3pm and see how the output looks like.

```{r, message = FALSE}
# estimate travel time matrix
ttm <- travel_time_matrix(r5r_core = r5r_core,   
                          origins = points,
                          destinations = points,    
                          mode = mode,
                          max_walk_time = max_walk_time,
                          max_trip_duration = max_trip_duration,
                          departure_datetime = departure_datetime,
                          progress = TRUE,
                          time_window = 60,
                          percentiles = c(10, 20, 50, 70, 80)
                          )

head(ttm, n = 10)

```

Now let's look at the 2nd row of the output above. This output tell us that only 10% of the trips between 2pm and 3pm for that origin-destination pair took 39 minutes or less. Meanwhile, 50% of those trips took up tp 45 minutes and 80% of them were 48-minute long or shorter.

The last row in the result above has a few `NA`s. This tell us that at least 50% of all simulated trips between 2pm and 3pm for that origin-destination pair could not be completed because they took longer than the `max_trip_duration` we have set (90 minutes).



### 3.4 Expanded travel time matrix with `time_window`.

Finally, we can also use the `time_window` in the `expanded_travel_time_matrix()` function. In this case, though, when the user sets a `time_window` value, the `expanded_travel_time_matrix()` will return the fastest route alternative departing each minute within the specified time window. Please note this function can be very memory intensive for large data sets and time windows.

```{r}
ettm <- r5r::expanded_travel_time_matrix(r5r_core = r5r_core,   
                                    origins = points[1:30,],
                                    destinations = points[31:61,],    
                                    mode = mode,
                                    max_walk_time = max_walk_time,
                                    max_trip_duration = max_trip_duration,
                                    departure_datetime = departure_datetime,
                                    progress = FALSE,
                                    time_window = 20)

head(ettm, n = 10)

```

### 3.5 Detailed itineraries with `time_window`.

In the `detailed_itineraries()` function, the number of Monte Carlo draws per minute is hardcoded to 1. This means that the function simulates only one departure per minute within the `time_window`. So if you set a `time_window` of 10 minutes, it would simulate 10 departures, one in each minute. This is largely because the `time_window` behaves slightly differently here.

See, functions like `travel_time_matrix()` or `accessibility()`, for example, return estimates of travel times or accessibility. In these cases, when we use the `time_window` parameter, these functions output selected percentiles of those values generated based on the distribution of all estimates that result from the multiple trip simulations.

The `detailed_itineraries()`, on the other hand, does not return travel times or accessibility estimates. It returns alternatives of trip journeys. In this case, when we use the `time_window` parameter, the function will return the optimal trip itinerary found within the time window. It can also return the optimal route along with multiple sub-optimal journey alternatives found within the time window if the the user sets `shortest_path = FALSE`.

*obs.* Mind you that `detailed_itineraries()` cannot be computed for public transport trips if the the network uses a frequencies-based GTFS feed. In these cases, we suggest using `gtfstools::frequencies_to_stop_times()` to create a suitable feed.



### Cleaning up after usage

`r5r` objects are still allocated to any amount of memory previously set after they are done with their calculations. In order to remove an existing `r5r` object and reallocate the memory it had been using, we use the `stop_r5` function followed by a call to Java's garbage collector, as follows:

```{r, message = FALSE}
r5r::stop_r5(r5r_core)
rJava::.jgc(R.gc = TRUE)
```

If you have any suggestions or want to report an error, please visit [the package GitHub page](https://github.com/ipeaGIT/r5r).

## References



--------------------------------------------------------------------------------
Vignette: travel_time_matrix.Rmd

---
title: 'Travel time matrices'
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
abstract: "This vignette shows how to use the travel_time_matrix() and expanded_travel_time_matrix() functions in r5r."
urlcolor: blue
vignette: >
  %\VignetteIndexEntry{Travel time matrices} 
  %\VignetteEngine{knitr::rmarkdown} 
  \usepackage[utf8]{inputenc}
bibliography: references.json
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  eval = identical(tolower(Sys.getenv("NOT_CRAN")), "true"),
  out.width = "100%"
)

## removes files previously created by 'setup_r5()'
#data_path <- system.file("extdata/poa", package = "r5r")
#existing_files <- list.files(data_path)
#files_to_keep <- c(
#  "poa_hexgrid.csv",
#  "poa_osm.pbf",
#  "poa_points_of_interest.csv",
#  "poa_eptc.zip",
#  "poa_trensurb.zip",
#  'fares'
#  )
#files_to_remove <- existing_files[! existing_files %in% files_to_keep]
#invisible(file.remove(file.path(data_path, files_to_remove)))
```

# 1. Introduction 

Some of the most common tasks in transport planning and modeling involve require having good quality data with travel time estimates between origins and destinations. `R5` is incredibly fast in generating realistic door-to-door travel time estimates in multimodal transport systems.

The `r5r` packages has two functions that allow users to leverage the computing power of `R5`:
- `travel_time_matrix()`
- `expanded_travel_time_matrix()`

This vignette shows a reproducible example to explain how these two functions work and the differences between them.


# 2. Build routable transport network with `setup_r5()`

First, let's build the multimodal transport network we'll be using in this vignette. In this example we'll be using the a sample data set for the city of Porto Alegre (Brazil) included in `r5r`.


```{r, message = FALSE}
# increase Java memory
options(java.parameters = "-Xmx2G")

# load libraries
library(r5r)
library(data.table)
library(ggplot2)

# build a routable transport network with r5r
data_path <- system.file("extdata/poa", package = "r5r")
r5r_core <- setup_r5(data_path)

# routing inputs
mode <- c('walk', 'transit')
max_trip_duration <- 60 # minutes

# departure time
departure_datetime <- as.POSIXct("13-05-2019 14:00:00", 
                                 format = "%d-%m-%Y %H:%M:%S")

# load origin/destination points
points <- fread(file.path(data_path, "poa_points_of_interest.csv"))

```


# 3. The `travel_time_matrix()` function

The `travel_time_matrix()` function provides a simple and really fast way to calculate the travel time between all possible origin destination pairs at a given departure time using a given transport mode.

The user can also customize many parameters such as:
- `max_trip_duration`: maximum trip duration
- `max_rides`: maximum number of transfer in the public transport system
- `max_walk_time` and `max_bike_time`: maximum walking or cycling time to and from public transport
- `walk_speed` and `bike_speed`: maximum walking or cycling speed
- `max_fare`: maximum monetary cost in public transport. [See this vignette](https://ipeagit.github.io/r5r/articles/fare_structure.html).


```{r, message = FALSE}
# estimate travel time matrix
ttm <- travel_time_matrix(r5r_core,   
                          origins = points,
                          destinations = points,    
                          mode = mode,
                          max_trip_duration = max_trip_duration,
                          departure_datetime = departure_datetime )

head(ttm, n = 10)

```

Now remember that travel time estimates can vary significantly across the day because of variations in public transport service levels. In order to account for this, you might want to calculate multiple travel time matrices departing at different times.

This can be done very efficiently by using the `time_window` and `percentile` parameters in the `travel_time_matrix()` function. When these parameters are set, R<sup>5</sup> will automatically compute multiple travel times estimates considering multiple departures per minute within the `time_window` selected by the user. [More information about this functionality can found in this vignette](https://ipeagit.github.io/r5r/articles/time_window.html).




# 4. The `expanded_travel_time_matrix()` function

Sometimes, we want to know more than simply the total travel time from A to B. This is when the `expanded_travel_time_matrix()` function comes in. By default, the output of this function will also tell which public transport routes were taken between each origin destination pair.

Nonetheless, you may set the parameter `breakdown = TRUE` to gather much more info for each trip. In this case, `expanded_travel_time_matrix()` will tell the number of transfers used to complete each trip and their total access, waiting, in-vehicle and transfer times. Please note that setting `breakdown = TRUE` can make the function slower for large data sets.

*A general call to expanded_travel_time_matrix()*
```{r, message = FALSE}
ettm <- expanded_travel_time_matrix(r5r_core,   
                                    origins = points,
                                    destinations = points,    
                                    mode = mode,
                                    max_trip_duration = max_trip_duration,
                                    departure_datetime = departure_datetime )

head(ettm, n = 10)
```

*Calling expanded_travel_time_matrix() with `breakdown = TRUE`*

```{r, message = FALSE}
ettm2 <- expanded_travel_time_matrix(r5r_core,   
                                    origins = points,
                                    destinations = points,    
                                    mode = mode,
                                    max_trip_duration = max_trip_duration,
                                    departure_datetime = departure_datetime,
                                    breakdown = TRUE)

head(ettm2, n = 10)
```

You will notice in the documentation that the `expanded_travel_time_matrix()` also has a `time_window` parameter. In this case, though, when the user sets a `time_window` value, the `expanded_travel_time_matrix()` will return the fastest route alternative departing each minute within the specified time window. Please note this function can be very memory intensive for large data sets and time windows.

```{r, message = FALSE}
ettm_window <- expanded_travel_time_matrix(r5r_core,   
                                           origins = points,
                                           destinations = points,    
                                           mode = mode,
                                           max_trip_duration = max_trip_duration,
                                           departure_datetime = departure_datetime,
                                           breakdown = TRUE,
                                           time_window = 10)

ettm_window[15:25,]
```
### Cleaning up after usage

`r5r` objects are still allocated to any amount of memory previously set after they are done with their calculations. In order to remove an existing `r5r` object and reallocate the memory it had been using, we use the `stop_r5` function followed by a call to Java's garbage collector, as follows:

```{r, message = FALSE}
r5r::stop_r5(r5r_core)
rJava::.jgc(R.gc = TRUE)
```

```{r, eval = TRUE, include = FALSE, message = FALSE}
# clean cache (CRAN policy)
r5r::r5r_cache(delete_file = 'all')

```

If you have any suggestions or want to report an error, please visit [the package GitHub page](https://github.com/ipeaGIT/r5r).

## References





--------------------------------------------------------------------------------
File: accessibility.R

accessibility <- function(r5r_core,
                          origins,
                          destinations,
                          opportunities_colnames = "opportunities",
                          mode = "WALK",
                          mode_egress = "WALK",
                          departure_datetime = Sys.time(),
                          time_window = 10L,
                          percentiles = 50L,
                          decay_function = "step",
                          cutoffs = NULL,
                          decay_value = NULL,
                          fare_structure = NULL,
                          max_fare = Inf,
                          max_walk_time = Inf,
                          max_bike_time = Inf,
                          max_car_time = Inf,
                          max_trip_duration = 120L,
                          walk_speed = 3.6,
                          bike_speed = 12,
                          max_rides = 3,
                          max_lts = 2,
                          draws_per_minute = 5L,
                          n_threads = Inf,
                          verbose = FALSE,
                          progress = FALSE,
                          output_dir = NULL) {

  old_options <- options(datatable.optimize = Inf)
  on.exit(options(old_options), add = TRUE)

  old_dt_threads <- data.table::getDTthreads()
  dt_threads <- ifelse(is.infinite(n_threads), 0, n_threads)
  data.table::setDTthreads(dt_threads)
  on.exit(data.table::setDTthreads(old_dt_threads), add = TRUE)

  # check inputs and set r5r options --------------------------------------

  checkmate::assert_class(r5r_core, "jobjRef")

  origins <- assign_points_input(origins, "origins")
  destinations <- assign_points_input(destinations, "destinations")
  opportunities <- assign_opportunities(destinations, opportunities_colnames)
  mode_list <- assign_mode(mode, mode_egress)
  departure <- assign_departure(departure_datetime)

  # check availability of transit services on the selected date
  if (mode_list$transit_mode %like% 'TRANSIT|TRAM|SUBWAY|RAIL|BUS|CABLE_CAR|GONDOLA|FUNICULAR') {
    check_transit_availability_on_date(r5r_core, departure_date = departure$date)
  }

  # cap trip duration with cutoffs
  set_cutoffs(r5r_core, cutoffs, decay_function)
  checkmate::assert_number(max_trip_duration, lower = 1, finite = TRUE)

  if(!is.null(cutoffs)){
    max_trip_duration <- ifelse(max_trip_duration > max(cutoffs), max(cutoffs), max_trip_duration)

    if(max_trip_duration < max(cutoffs)){stop("'max_trip_duration' cannot be shorter than 'max(cutoffs)'")}
  }

  max_walk_time <- assign_max_street_time(
    max_walk_time,
    walk_speed,
    max_trip_duration,
    "walk"
  )
  max_bike_time <- assign_max_street_time(
    max_bike_time,
    bike_speed,
    max_trip_duration,
    "bike"
  )
  max_car_time <- assign_max_street_time(
    max_car_time,
    8, # 8 km/h, R5's default.
    max_trip_duration,
    "car"
  )
  max_trip_duration <- assign_max_trip_duration(
    max_trip_duration,
    mode_list,
    max_walk_time,
    max_bike_time
  )


  decay_list <- assign_decay_function(decay_function, decay_value)

  set_time_window(r5r_core, time_window)
  set_percentiles(r5r_core, percentiles)
  set_monte_carlo_draws(r5r_core, draws_per_minute, time_window)
  set_speed(r5r_core, walk_speed, "walk")
  set_speed(r5r_core, bike_speed, "bike")
  set_max_rides(r5r_core, max_rides)
  set_max_lts(r5r_core, max_lts)
  set_n_threads(r5r_core, n_threads)
  set_verbose(r5r_core, verbose)
  set_progress(r5r_core, progress)
  set_fare_structure(r5r_core, fare_structure)
  set_max_fare(r5r_core, max_fare)
  set_output_dir(r5r_core, output_dir)

  # call r5r_core method and process results ------------------------------

  # wrap r5r_core inputs in arrays (this helps to simplify the Java code)

  from_id_arr <- rJava::.jarray(origins$id)
  from_lat_arr <- rJava::.jarray(origins$lat)
  from_lon_arr <- rJava::.jarray(origins$lon)

  to_id_arr <- rJava::.jarray(destinations$id)
  to_lat_arr <- rJava::.jarray(destinations$lat)
  to_lon_arr <- rJava::.jarray(destinations$lon)

  opportunities_names <- rJava::.jarray(opportunities_colnames)
  opportunities_values <- rJava::.jarray(opportunities, "[I")

  accessibility <- r5r_core$accessibility(
    from_id_arr,
    from_lat_arr,
    from_lon_arr,
    to_id_arr,
    to_lat_arr,
    to_lon_arr,
    opportunities_names,
    opportunities_values,
    decay_list$fun,
    decay_list$value,
    mode_list$direct_modes,
    mode_list$transit_mode,
    mode_list$access_mode,
    mode_list$egress_mode,
    departure$date,
    departure$time,
    max_walk_time,
    max_bike_time,
    max_car_time,
    max_trip_duration
  )

  if (!verbose & progress) cat("Preparing final output...", file = stderr())

  accessibility <- java_to_dt(accessibility)

  if (decay_function == "fixed_exponential") accessibility[, cutoff := NULL]

  if (!verbose & progress) cat(" DONE!\n", file = stderr())

  if (!is.null(output_dir)) return(output_dir)
  return(accessibility[])
}



--------------------------------------------------------------------------------
File: assign.R

assign_points_input <- function(df, name) {
  if (!inherits(df, "data.frame")) {
    stop("'", name, "' must be either a 'data.frame' or a 'POINT sf'.")
  }

  if ("sf" %in% class(df)) {
    if (
      as.character(sf::st_geometry_type(df, by_geometry = FALSE)) != "POINT"
    ) {
      stop("'", name, "' must be either a 'data.frame' or a 'POINT sf'.")
    }

    if (sf::st_crs(df) != sf::st_crs(4326)) {
      stop(
        "'", name, "' CRS must be WGS 84 (EPSG 4326). ",
        "Please use either sf::set_crs() to set it or ",
        "sf::st_transform() to reproject it."
      )
    }

    df <- sfheaders::sf_to_df(df, fill = TRUE)
    data.table::setDT(df)
    data.table::setnames(df, c("x", "y"), c("lon", "lat"))
  }

  checkmate::assert_names(
    names(df),
    must.include = c("id", "lat", "lon"),
    .var.name = name
  )
  checkmate::assert_numeric(df$lon, .var.name = paste0(name, "$lon"))
  checkmate::assert_numeric(df$lat, .var.name = paste0(name, "$lat"))

  if (!is.character(df$id)) {
    df$id <- as.character(df$id)
    warning("'", name, "$id' forcefully cast to character.")
  }

  return(df)
}


assign_mode <- function(mode, mode_egress, style) {
  dr_modes <- c("WALK", "BICYCLE", "CAR", "BICYCLE_RENT", "CAR_PARK")
  tr_modes <- c(
    "TRANSIT",
    "TRAM",
    "SUBWAY",
    "RAIL",
    "BUS",
    "FERRY",
    "CABLE_CAR",
    "GONDOLA",
    "FUNICULAR"
  )
  all_modes <- c(tr_modes, dr_modes)

  mode <- toupper(unique(mode))
  checkmate::assert(
    checkmate::check_character(mode, min.len = 1, any.missing = FALSE),
    checkmate::check_names(mode, subset.of = all_modes),
    combine = "and"
  )

  mode_egress <- toupper(unique(mode_egress))
  checkmate::assert_string(mode_egress)
  checkmate::assert_names(
    mode_egress,
    subset.of = setdiff(dr_modes, c("CAR_PARK", "BICYCLE_RENT"))
  )

  direct_modes <- mode[which(mode %in% dr_modes)]
  transit_modes <- mode[which(mode %in% tr_modes)]

  if (length(direct_modes) > 1) {
    stop(
      "Please use only 1 of {",
      paste0("'", direct_modes, "'", collapse = ","),
      "} when routing."
    )
  }

  if (any(c("CAR_PARK", "BICYCLE_RENT") %in% direct_modes)) {
    stop("CAR_PARK and BICYCLE_RENT are currently unsupported by r5r.")
  }

  access_mode <- direct_modes

  if (length(transit_modes) == 0) {
    transit_modes <- ""
    egress_mode <- ""
  } else {
    if ("TRANSIT" %in% transit_modes) transit_modes <- tr_modes

    # if only transit mode is passed, assume "WALK" as access_mode
    if (length(direct_modes) == 0) access_mode <- direct_modes <- "WALK"

    egress_mode <- mode_egress
  }

  mode_list <- list(
    direct_modes = paste0(direct_modes, collapse = ";"),
    transit_mode = paste0(transit_modes, collapse = ";"),
    access_mode = paste0(access_mode, collapse = ";"),
    egress_mode = paste0(egress_mode, collapse = ";")
  )

  return(mode_list)
}


assign_departure <- function(datetime) {
  checkmate::assert_posixct(
    datetime,
    len = 1,
    any.missing = FALSE,
    .var.name = "departure_datetime"
  )

  tz <- attr(datetime, "tzone")
  if (is.null(tz)) tz <- ""

  datetime_list <- list(
    date = strftime(datetime, format = "%Y-%m-%d", tz = tz),
    time = strftime(datetime, format = "%H:%M:%S", tz = tz)
  )

  return(datetime_list)
}


assign_max_street_time <- function(max_time, speed, max_trip_duration, mode) {

  checkmate::assert(
    checkmate::check_string(mode),
    checkmate::check_names(mode, subset.of = c("bike", "walk", "car")),
    combine = "and"
  )

  checkmate::assert_number(
    max_time,
    .var.name = paste0("max_", mode, "_time"),
    lower = 1,
    finite = FALSE
  )

  checkmate::assert_number(
    speed,
    finite = TRUE,
    .var.name = paste0(mode, "_speed")
  )

  checkmate::assert_number(max_trip_duration, lower = 1, finite = TRUE)

  if (speed <= 0) {
    stop(
      "Assertion on '", mode, "_speed' failed: ",
      "Must have value greater than 0."
    )
  }

  if (is.infinite(max_time)){
    return(as.integer(max_trip_duration))
  }
  else {
    return(as.integer(max_time))
    }
}


assign_max_trip_duration <- function(max_trip_duration,
                                     modes,
                                     max_walk_time,
                                     max_bike_time) {
  checkmate::assert_number(max_trip_duration, lower = 1, finite = TRUE)

  max_trip_duration <- as.integer(max_trip_duration)

  if (modes$transit_mode == "") {
    if (modes$direct_modes == "WALK" & max_walk_time < max_trip_duration) {
      max_trip_duration <- max_walk_time
    }
    if (modes$direct_modes == "BICYCLE" & max_bike_time < max_trip_duration) {
      max_trip_duration <- max_bike_time
    }
  }

  return(max_trip_duration)
}


assign_opportunities <- function(destinations, opportunities_colnames) {
  checkmate::assert_character(
    opportunities_colnames,
    min.len = 1,
    unique = TRUE,
    any.missing = FALSE
  )
  checkmate::assert_names(
    names(destinations),
    must.include = opportunities_colnames,
    .var.name = "destinations"
  )

  opportunities_data <- lapply(
    opportunities_colnames,
    function(colname) {
      checkmate::assert_numeric(destinations[[colname]])

      opp_array <- as.integer(destinations[[colname]])
      opp_array <- rJava::.jarray(opp_array)

      opp_array
    }
  )

  return(opportunities_data)
}


assign_decay_function <- function(decay_function, decay_value) {
  all_functions  <- c(
    "step",
    "exponential",
    "fixed_exponential",
    "linear",
    "logistic"
  )
  checkmate::assert(
    checkmate::check_string(decay_function),
    checkmate::check_names(decay_function, subset.of = all_functions),
    combine = "and"
  )
  checkmate::assert_number(decay_value, finite = TRUE, null.ok = TRUE)

  non_null_decay <- c("fixed_exponential", "linear", "logistic")
  if (!is.null(decay_value) & decay_function %in% c("step", "exponential")) {
    stop(
      "Assertion on decay_value failed: must be NULL when decay_function ",
      "is ", decay_function, "."
    )
  } else if (is.null(decay_value) & decay_function %in% non_null_decay) {
    stop(
      "Assertion on decay_value failed: must not be NULL when decay_function ",
      "is ", decay_function, "."
    )
  }

  if (decay_function == "fixed_exponential") {
    if (decay_value <= 0 | decay_value >= 1) {
      stop(
        "Assertion on decay_value failed: must be a number between 0 and 1 ",
        "(exclusive) when decay_function is fixed_exponential."
      )
    }
  }

  if (decay_function %in% c("logistic", "linear")) {
    if (decay_value < 1) {
      stop(
        "Assertion on decay_value failed: must be a number greater than or ",
        "equal to 1 when decay_function is ",
        decay_function, "."
      )
    }
  }

  decay_function <- toupper(decay_function)

  # java does not accept NULL values, so if decay_value is NULL we assign a
  # placeholder number to it (it's ignored in R5 anyway)

  if (is.null(decay_value)) {
    decay_value <- 0
  } else {
    decay_value <- as.double(decay_value)
  }

  decay_list <- list("fun" = decay_function, "value" = decay_value)

  return(decay_list)
}


assign_shortest_path <- function(shortest_path) {
  checkmate::assert_logical(shortest_path, len = 1, any.missing = FALSE)

  return(shortest_path)
}


assign_drop_geometry <- function(drop_geometry) {
  checkmate::assert_logical(drop_geometry, len = 1, any.missing = FALSE)

  return(drop_geometry)
}



--------------------------------------------------------------------------------
File: detailed_itineraries.R

detailed_itineraries <- function(r5r_core,
                                 origins,
                                 destinations,
                                 mode = "WALK",
                                 mode_egress = "WALK",
                                 departure_datetime = Sys.time(),
                                 time_window = 10L,
                                 suboptimal_minutes = 0L,
                                 fare_structure = NULL,
                                 max_fare = Inf,
                                 max_walk_time = Inf,
                                 max_bike_time = Inf,
                                 max_car_time = Inf,
                                 max_trip_duration = 120L,
                                 walk_speed = 3.6,
                                 bike_speed = 12,
                                 max_rides = 3,
                                 max_lts = 2,
                                 shortest_path = TRUE,
                                 all_to_all = FALSE,
                                 n_threads = Inf,
                                 verbose = FALSE,
                                 progress = FALSE,
                                 drop_geometry = FALSE,
                                 output_dir = NULL) {

  old_options <- options(datatable.optimize = Inf)
  on.exit(options(old_options), add = TRUE)

  old_dt_threads <- data.table::getDTthreads()
  dt_threads <- ifelse(is.infinite(n_threads), 0, n_threads)
  data.table::setDTthreads(dt_threads)
  on.exit(data.table::setDTthreads(old_dt_threads), add = TRUE)

  # check inputs and set r5r options --------------------------------------

  checkmate::assert_class(r5r_core, "jobjRef")

  origins <- assign_points_input(origins, "origins")
  destinations <- assign_points_input(destinations, "destinations")
  od_list <- expand_od_pairs(origins, destinations, all_to_all)
  origins <- od_list$origins
  destinations <- od_list$destinations

  mode_list <- assign_mode(mode, mode_egress)

  # detailed itineraries via public transport cannot be computed on frequencies-based GTFS
  if (mode_list$transit_mode != "" & r5r_core$hasFrequencies()) {
    stop(
      "Assertion on 'r5r_core' failed: None of the GTFS feeds used to create ",
      "the transit network can contain a 'frequencies' table. Try using ",
      "gtfstools::frequencies_to_stop_times() to create a suitable feed."
    )
  }

  departure <- assign_departure(departure_datetime)

  # check availability of transit services on the selected date
  if (mode_list$transit_mode %like% 'TRANSIT|TRAM|SUBWAY|RAIL|BUS|CABLE_CAR|GONDOLA|FUNICULAR') {
    check_transit_availability_on_date(r5r_core, departure_date = departure$date)
  }

  max_walk_time <- assign_max_street_time(
    max_walk_time,
    walk_speed,
    max_trip_duration,
    "walk"
  )
  max_bike_time <- assign_max_street_time(
    max_bike_time,
    bike_speed,
    max_trip_duration,
    "bike"
  )
  max_car_time <- assign_max_street_time(
    max_car_time,
    8, # 8 km/h, R5's default.
    max_trip_duration,
    "car"
  )
  max_trip_duration <- assign_max_trip_duration(
    max_trip_duration,
    mode_list,
    max_walk_time,
    max_bike_time
  )
  shortest_path <- assign_shortest_path(shortest_path)
  drop_geometry <- assign_drop_geometry(drop_geometry)

  set_time_window(r5r_core, time_window)
  set_monte_carlo_draws(r5r_core, 1, time_window)
  set_speed(r5r_core, walk_speed, "walk")
  set_speed(r5r_core, bike_speed, "bike")
  set_max_rides(r5r_core, max_rides)
  set_max_lts(r5r_core, max_lts)
  set_n_threads(r5r_core, n_threads)
  set_verbose(r5r_core, verbose)
  set_progress(r5r_core, progress)
  set_fare_structure(r5r_core, fare_structure)
  set_max_fare(r5r_core, max_fare)
  set_output_dir(r5r_core, output_dir)
  set_suboptimal_minutes(
    r5r_core,
    suboptimal_minutes,
    fare_structure,
    shortest_path
  )

  # call r5r_core method and process result -------------------------------

  path_options <- r5r_core$detailedItineraries(
    origins$id,
    origins$lat,
    origins$lon,
    destinations$id,
    destinations$lat,
    destinations$lon,
    mode_list$direct_modes,
    mode_list$transit_mode,
    mode_list$access_mode,
    mode_list$egress_mode,
    departure$date,
    departure$time,
    max_walk_time,
    max_bike_time,
    max_car_time,
    max_trip_duration,
    drop_geometry,
    shortest_path
  )

  if (!is.null(output_dir)) return(output_dir)

  path_options <- java_to_dt(path_options)

  if (!drop_geometry) {
    if (nrow(path_options) > 0) {
      path_options[, geometry := sf::st_as_sfc(geometry)]
    } else {
      path_options[, geometry := sf::st_sfc(sf::st_linestring(), crs = 4326)[0]]
    }

    path_options <- sf::st_sf(path_options, crs = 4326)
  }

  return(path_options)
}



--------------------------------------------------------------------------------
File: download_r5.R

download_r5 <- function(version = NULL,
                        quiet = FALSE,
                        force_update = FALSE,
                        temp_dir = FALSE) {

  # R5 version
  if(is.null(version)) {version = r5r_env$r5_jar_version}


  # check inputs ----------------------------------------------------------

  checkmate::assert_logical(quiet)
  checkmate::assert_logical(force_update)
  checkmate::assert_logical(temp_dir)


  # set timeout options ---------------------------------------------------

  old_options <- options()
  on.exit(options(old_options), add = TRUE)

  options(timeout = max(600, getOption("timeout")))


  # download R5 jar -----------------------------------------------------

  if (!dir.exists(r5r_env$cache_dir)) {dir.create(r5r_env$cache_dir, recursive = TRUE)}

  file_url <- fileurl_from_metadata(version)
  filename <- basename(file_url)

  jar_file <- data.table::fifelse(
    temp_dir,
    file.path(tempdir(), filename),
    file.path( r5r_env$cache_dir , filename)
  )

  # check if the file exists and is not corrupted
  if (file.exists(jar_file) && file.info(jar_file)$size < r5r_env$r5_jar_size && isFALSE(force_update)) {
    stop(message("R5 Jar file is corrupted. To fix this problem, download it again with 'r5r::download_r5(force_update = TRUE)'"))
  }

  # check if the file exists, and returns its path if it does. otherwise,
  # download it from IPEA's server - if there's no internet connection "fail
  # gracefully" (i.e invisibly returns NULL and outputs a informative message)"
  if (file.exists(jar_file) && (force_update == FALSE)) {
    if (!quiet) message("Using cached R5 version from ", jar_file)
    return(jar_file)
  }

  # download JAR
  message("Downloading R5 jar file to ", jar_file)

  try(silent = TRUE,
      utils::download.file(
        url = file_url,
        destfile = jar_file,
        mode = "wb",
        # method = "curl",
        # extra = "--insecure",
        quiet = quiet
      )
  )

  # try(silent = TRUE,
  #     httr::GET(url=file_url,
  #               if(isFALSE(quiet)){ httr::progress()},
  #               httr::write_disk(jar_file, overwrite = TRUE),
  #               config = httr::config(ssl_verifypeer = FALSE))
  # )


# Halt function if download failed (file must exist and be larger than 60 MB)
if (!file.exists(jar_file) | file.info(jar_file)$size < r5r_env$r5_jar_size) {
  message('Internet connection not working properly.')
  return(invisible(NULL))
  }

  return(jar_file)

}



--------------------------------------------------------------------------------
File: expand_od_pairs.R

expand_od_pairs <- function(origins, destinations, all_to_all) {
  checkmate::assert_logical(all_to_all, len = 1, any.missing = FALSE)

  n_origs <- nrow(origins)
  n_dests <- nrow(destinations)

  if (all_to_all || n_origs == 1 || n_dests == 1) {
    origins <- origins[rep(1:n_origs, each = n_dests), ]
    destinations <- destinations[rep(1:n_dests, times = n_origs), ]

    if (!all_to_all && (n_origs > 1 || n_dests > 1)) {
      if (n_origs == 1) {
        message("'origins' was expanded to match the number of destinations.")
      } else {
        message("'destinations' was expanded to match the number of origins.")
      }
    }
  } else if (n_origs != n_dests) {
    stop(
      "When 'all_to_all' is FALSE, 'origins' and 'destinations' must either ",
      "have the same number of rows or one of them must have only one row."
    )
  }

  result <- list(origins = origins, destinations = destinations)
  return(result)
}



--------------------------------------------------------------------------------
File: expanded_travel_time_matrix.R

expanded_travel_time_matrix <- function(r5r_core,
                                        origins,
                                        destinations,
                                        mode = "WALK",
                                        mode_egress = "WALK",
                                        departure_datetime = Sys.time(),
                                        time_window = 10L,
                                        breakdown = FALSE,
                                        max_walk_time = Inf,
                                        max_bike_time = Inf,
                                        max_car_time = Inf,
                                        max_trip_duration = 120L,
                                        walk_speed = 3.6,
                                        bike_speed = 12,
                                        max_rides = 3,
                                        max_lts = 2,
                                        draws_per_minute = 5L,
                                        n_threads = Inf,
                                        verbose = FALSE,
                                        progress = FALSE,
                                        output_dir = NULL) {

  old_options <- options(datatable.optimize = Inf)
  on.exit(options(old_options), add = TRUE)

  old_dt_threads <- data.table::getDTthreads()
  dt_threads <- ifelse(is.infinite(n_threads), 0, n_threads)
  data.table::setDTthreads(dt_threads)
  on.exit(data.table::setDTthreads(old_dt_threads), add = TRUE)

  # check inputs and set r5r options --------------------------------------

  checkmate::assert_class(r5r_core, "jobjRef")

  origins <- assign_points_input(origins, "origins")
  destinations <- assign_points_input(destinations, "destinations")
  mode_list <- assign_mode(mode, mode_egress)
  departure <- assign_departure(departure_datetime)

  # check availability of transit services on the selected date
  if (mode_list$transit_mode %like% 'TRANSIT|TRAM|SUBWAY|RAIL|BUS|CABLE_CAR|GONDOLA|FUNICULAR') {
    check_transit_availability_on_date(r5r_core, departure_date = departure$date)
  }

  max_walk_time <- assign_max_street_time(
    max_walk_time,
    walk_speed,
    max_trip_duration,
    "walk"
  )
  max_bike_time <- assign_max_street_time(
    max_bike_time,
    bike_speed,
    max_trip_duration,
    "bike"
  )
  max_car_time <- assign_max_street_time(
    max_car_time,
    8, # 8 km/h, R5's default.
    max_trip_duration,
    "car"
  )
  max_trip_duration <- assign_max_trip_duration(
    max_trip_duration,
    mode_list,
    max_walk_time,
    max_bike_time
  )

  set_time_window(r5r_core, time_window)
  set_monte_carlo_draws(r5r_core, draws_per_minute, time_window)
  set_speed(r5r_core, walk_speed, "walk")
  set_speed(r5r_core, bike_speed, "bike")
  set_max_rides(r5r_core, max_rides)
  set_max_lts(r5r_core, max_lts)
  set_n_threads(r5r_core, n_threads)
  set_verbose(r5r_core, verbose)
  set_progress(r5r_core, progress)
  set_output_dir(r5r_core, output_dir)
  set_expanded_travel_times(r5r_core, TRUE)
  set_breakdown(r5r_core, breakdown)
  set_fare_structure(r5r_core, NULL)

  # call r5r_core method and process result -------------------------------

  travel_times <- r5r_core$travelTimeMatrix(
    origins$id,
    origins$lat,
    origins$lon,
    destinations$id,
    destinations$lat,
    destinations$lon,
    mode_list$direct_modes,
    mode_list$transit_mode,
    mode_list$access_mode,
    mode_list$egress_mode,
    departure$date,
    departure$time,
    max_walk_time,
    max_bike_time,
    max_car_time,
    max_trip_duration
  )

  if (!verbose & progress) cat("Preparing final output...", file = stderr())

  travel_times <- java_to_dt(travel_times)

  # replace travel-times of non-viable trips with NAs
  # if breakdown is TRUE, there are more columns in the output

  if (nrow(travel_times) > 0) {
    if (breakdown) {
      travel_times[
        total_time > max_trip_duration,
        `:=`(
          access_time = NA_integer_,
          wait_time = NA_integer_,
          ride_time = NA_integer_,
          transfer_time = NA_integer_,
          egress_time = NA_integer_,
          routes = NA_character_,
          n_rides = NA_integer_,
          total_time = NA_integer_
        )
      ]
    } else {
      travel_times[
        total_time > max_trip_duration,
        `:=`(routes = NA_character_, total_time = NA_integer_)
      ]
    }
  }

  if (!verbose & progress) cat(" DONE!\n", file = stderr())

  if (!is.null(output_dir)) return(output_dir)
  return(travel_times[])
}



--------------------------------------------------------------------------------
File: fare_structure.R

setup_fare_structure <- function(r5r_core,
                                 base_fare,
                                 by = "MODE",
                                 debug_path = NULL,
                                 debug_info = NULL) {
  checkmate::assert_class(r5r_core, "jobjRef")
  checkmate::assert_numeric(base_fare, lower = 0, len = 1, any.missing = FALSE)

  by_options <- c("MODE", "AGENCY_ID", "AGENCY_NAME", "GENERIC")
  by <- toupper(by)
  checkmate::assert(
    checkmate::check_string(by),
    checkmate::check_names(by, subset.of = by_options),
    combine = "and"
  )

  checkmate::assert_string(debug_path, pattern = "\\.csv$", null.ok = TRUE)

  if (is.null(debug_path) && !is.null(debug_info)) {
    stop("Please specify a file to write debug info to with 'debug_path'.")
  } else if (!is.null(debug_path) && is.null(debug_info)) {
    debug_info <- "ROUTE"
  }

  debug_info_options <- c("MODE", "ROUTE", "MODE_ROUTE")
  checkmate::assert_string(debug_info, null.ok = TRUE)
  if (!is.null(debug_info)) {
    debug_info <- toupper(debug_info)
    checkmate::assert_names(debug_info, subset.of = debug_info_options)
  }

  # r5r_core method to build fare structure returns a json

  f_struct <- r5r_core$buildFareStructure(rJava::.jfloat(base_fare), by)
  json_string <- f_struct$toJson()

  fare_structure <- jsonlite::parse_json(json_string, simplifyVector = TRUE)

  # Inf values are not supported by Java, so we use -1 to represent them

  if (fare_structure$fare_cap <= 0) fare_structure$fare_cap <- Inf

  if (!is.null(debug_path)) {
    debug <- list(
      output_file = debug_path,
      trip_info = debug_info
    )
  } else {
    debug <- list(
      output_file = "",
      trip_info = "MODE"
    )
  }
  fare_structure$debug_settings <- debug

  data.table::setDT(fare_structure$fares_per_type)
  data.table::setDT(fare_structure$fares_per_transfer)
  data.table::setDT(fare_structure$fares_per_route)

  return(fare_structure)
}


write_fare_structure <- function(fare_structure, file_path) {
  checkmate::assert_string(file_path, pattern = "\\.zip$", null.ok = TRUE)

  fare_global_settings <- data.table::data.table(
    setting = c(
      "max_discounted_transfers",
      "transfer_time_allowance",
      "fare_cap"
    ),
    value = c(
      fare_structure$max_discounted_transfers,
      fare_structure$transfer_time_allowance,
      fare_structure$fare_cap
    )
  )

  fare_debug_settings <- data.table::data.table(
    setting = c("output_file", "trip_info"),
    value = c(
      fare_structure$debug_settings$output_file,
      fare_structure$debug_settings$trip_info
    )
  )

  tmpdir <- tempfile(pattern = "r5r_fare_structure")
  dir.create(tmpdir)
  tmpfile <- function(path) file.path(tmpdir, path)

  data.table::fwrite(fare_global_settings, tmpfile("global_settings.csv"))
  data.table::fwrite(
    fare_structure$fares_per_type,
    tmpfile("fares_per_type.csv")
  )
  data.table::fwrite(
    fare_structure$fares_per_transfer,
    tmpfile("fares_per_transfer.csv")
  )
  data.table::fwrite(
    fare_structure$fares_per_route,
    tmpfile("fares_per_route.csv")
  )
  data.table::fwrite(fare_debug_settings, tmpfile("debug_settings.csv"))

  zip::zip(
    zipfile = file_path,
    files = c(
      normalizePath(tmpfile("global_settings.csv")),
      normalizePath(tmpfile("fares_per_type.csv")),
      normalizePath(tmpfile("fares_per_transfer.csv")),
      normalizePath(tmpfile("fares_per_route.csv")),
      normalizePath(tmpfile("debug_settings.csv"))
    ),
    mode = "cherry-pick"
  )

  return(invisible(file_path))
}


read_fare_structure <- function(file_path, encoding = "UTF-8") {
  checkmate::assert_file_exists(file_path, extension = "zip")
  val_enc <- c("unknown", "UTF-8", "Latin-1")
  checkmate::assert(
    checkmate::check_string(encoding),
    checkmate::check_names(encoding, subset.of = val_enc),
    combine = "and"
  )

  tmpdir <- tempfile("read_fare_structure")
  dir.create(tmpdir)
  zip::unzip(zipfile = file_path, exdir = tmpdir)

  tmpfile <- function(path) file.path(tmpdir, path)

  global_settings <- data.table::fread(
    tmpfile("global_settings.csv"),
    encoding = encoding
  )

  fare_structure <- list()

  fare_structure$max_discounted_transfers <- as.integer(
    global_settings[setting == "max_discounted_transfers"]$value
  )
  fare_structure$transfer_time_allowance <- as.integer(
    global_settings[setting == "transfer_time_allowance"]$value
  )
  fare_structure$fare_cap <- as.numeric(
    global_settings[setting == "fare_cap"]$value
  )

  fare_structure$fares_per_type <- data.table::fread(
    tmpfile("fares_per_type.csv"),
    select = c(
      type = "character",
      unlimited_transfers = "logical",
      allow_same_route_transfer = "logical",
      use_route_fare = "logical",
      fare = "numeric"
    ),
    encoding = encoding
  )

  fare_structure$fares_per_transfer <- data.table::fread(
    file = tmpfile("fares_per_transfer.csv"),
    select = c(
      first_leg = "character",
      second_leg = "character",
      fare = "numeric"
    ),
    encoding = encoding
  )

  fare_structure$fares_per_route <- data.table::fread(
    file = tmpfile("fares_per_route.csv"),
    select = c(
      agency_id = "character",
      agency_name = "character",
      route_id = "character",
      route_short_name = "character",
      route_long_name = "character",
      mode = "character",
      route_fare = "numeric",
      fare_type = "character"
    ),
    encoding = encoding
  )

  debug_options <- data.table::fread(
    tmpfile("debug_settings.csv"),
    encoding = encoding
  )
  fare_structure$debug_settings <- list(
    output_file = debug_options[setting == "output_file"]$value,
    trip_info = debug_options[setting == "trip_info"]$value
  )

  return(fare_structure)
}


assert_fare_structure <- function(fare_structure) {
  # TODO: all GTFS routes must be in fares_per_route
  # TODO: fares_per_route$route_id must be unique
  checkmate::assert_list(fare_structure, any.missing = FALSE)

  if ("type" %in% names(fare_structure)) {
    # this is an R5 built-in fare structure
    return(invisible(TRUE))
  } else {
    # This is an R5R fare structure object
    
    element_names <- c(
      "max_discounted_transfers",
      "transfer_time_allowance",
      "fare_cap",
      "fares_per_type",
      "fares_per_transfer",
      "fares_per_route",
      "debug_settings"
    )
    checkmate::assert_names(
      names(fare_structure),
      type = "unique",
      must.include = element_names,
      subset.of = element_names
    )

    checkmate::assert_number(fare_structure$max_discounted_transfers, lower = 0)
    checkmate::assert_number(fare_structure$transfer_time_allowance, lower = 0)
    checkmate::assert_number(fare_structure$fare_cap, lower = 0)

    checkmate::expect_data_frame(fare_structure$fares_per_type)
    checkmate::expect_character(
      fare_structure$fares_per_type$type,
      any.missing = FALSE,
      unique = TRUE
    )
    checkmate::expect_logical(
      fare_structure$fares_per_type$unlimited_transfers,
      any.missing = FALSE
    )
    checkmate::expect_logical(
      fare_structure$fares_per_type$allow_same_route_transfer,
      any.missing = FALSE
    )
    checkmate::expect_logical(
      fare_structure$fares_per_type$use_route_fare,
      any.missing = FALSE
    )
    checkmate::expect_numeric(
      fare_structure$fares_per_type$fare,
      any.missing = FALSE,
      lower = 0,
      finite = TRUE
    )

    checkmate::expect_data_frame(fare_structure$fares_per_transfer)
    if (length(names(fare_structure$fares_per_transfer)) > 0) {
      checkmate::expect_character(
        fare_structure$fares_per_transfer$first_leg,
        any.missing = FALSE
      )
      checkmate::assert_names(
        fare_structure$fares_per_transfer$first_leg,
        subset.of = unique(fare_structure$fares_per_type$type)
      )
      checkmate::expect_character(
        fare_structure$fares_per_transfer$second_leg,
        any.missing = FALSE
      )
      checkmate::assert_names(
        fare_structure$fares_per_transfer$second_leg,
        subset.of = unique(fare_structure$fares_per_type$type)
      )
      checkmate::expect_numeric(
        fare_structure$fares_per_transfer$fare,
        any.missing = FALSE,
        lower = 0,
        finite = TRUE
      )
    }

    checkmate::expect_data_frame(fare_structure$fares_per_route)
    checkmate::expect_character(
      fare_structure$fares_per_route$agency_id,
      any.missing = FALSE
    )
    checkmate::expect_character(
      fare_structure$fares_per_route$agency_name,
      any.missing = FALSE
    )
    checkmate::expect_character(
      fare_structure$fares_per_route$route_id,
      any.missing = FALSE
    )
    checkmate::expect_character(
      fare_structure$fares_per_route$route_short_name,
      any.missing = FALSE
    )
    checkmate::expect_character(
      fare_structure$fares_per_route$route_long_name,
      any.missing = FALSE
    )
    checkmate::expect_character(
      fare_structure$fares_per_route$mode,
      any.missing = FALSE
    )
    checkmate::expect_numeric(
      fare_structure$fares_per_route$route_fare,
      any.missing = FALSE,
      lower = 0,
      finite = TRUE
    )
    checkmate::expect_character(
      fare_structure$fares_per_route$fare_type,
      any.missing = FALSE
    )
    checkmate::assert_names(
      fare_structure$fares_per_route$fare_type,
      subset.of = unique(fare_structure$fares_per_type$type)
    )

    debug_elements <- c("output_file", "trip_info")
    checkmate::assert_list(fare_structure$debug_settings)
    checkmate::assert_names(
      names(fare_structure$debug_settings),
      type = "unique",
      must.include = debug_elements,
      subset.of = debug_elements
    )
    checkmate::assert_string(fare_structure$debug_settings$output_file)
    checkmate::assert_string(fare_structure$debug_settings$trip_info)

    return(invisible(TRUE))
  }
}



--------------------------------------------------------------------------------
File: find_snap.R

find_snap <- function(r5r_core, points, mode = "WALK") {
  checkmate::assert_class(r5r_core, "jobjRef")

  mode_options <- c("WALK", "BICYCLE", "CAR")
  checkmate::assert(
    checkmate::check_string(mode),
    checkmate::check_names(mode, subset.of = mode_options),
    combine = "and"
  )

  points <- assign_points_input(points, "points")

  snap_df <- r5r_core$findSnapPoints(points$id, points$lat, points$lon, mode)
  snap_df <- java_to_dt(snap_df)

  snap_df[found == FALSE, `:=`(snap_lat = NA, snap_lon = NA, distance = NA)]

  return(snap_df)
}






--------------------------------------------------------------------------------
File: isochrone.R

isochrone <- function(r5r_core,
                      origins,
                      mode = "transit",
                      mode_egress = "walk",
                      cutoffs = c(0, 15, 30),
                      sample_size = 0.8,
                      departure_datetime = Sys.time(),
                      polygon_output = TRUE,
                      time_window = 10L,
                      max_walk_time = Inf,
                      max_bike_time = Inf,
                      max_car_time = Inf,
                      max_trip_duration = 120L,
                      walk_speed = 3.6,
                      bike_speed = 12,
                      max_rides = 3,
                      max_lts = 2,
                      draws_per_minute = 5L,
                      n_threads = Inf,
                      verbose = FALSE,
                      progress = TRUE){


# check inputs ------------------------------------------------------------

  # check cutoffs
  checkmate::assert_numeric(cutoffs, lower = 0)
  checkmate::assert_logical(polygon_output)

  # check sample_size
  checkmate::assert_numeric(sample_size, lower = 0.2, upper = 1, max.len = 1)

  # max cutoff is used as max_trip_duration
  max_trip_duration = as.integer(max(cutoffs))

  # include 0 in cutoffs
  if (min(cutoffs) > 0) {cutoffs <- sort(c(0, cutoffs))}


# IF no destinations input ------------------------------------------------------------


  ## whether polygon- or line-based isochrones
  if (isTRUE(polygon_output)) {

    # use all network nodes as destination points
    destinations = r5r::street_network_to_sf(r5r_core)$vertices

    # sample size: proportion of nodes to be considered
    set.seed(42)
    index_sample <- sample(1:nrow(destinations),
                           size = nrow(destinations) * sample_size,
                           replace = FALSE)
    destinations <- destinations[index_sample,]
    on.exit(rm(.Random.seed, envir=globalenv()))
  }

  if(isFALSE(polygon_output)){

    network_e <- r5r::street_network_to_sf(r5r_core)$edges

    destinations <- sf::st_centroid(network_e)
    }

  # rename id col
  names(destinations)[1] <- 'id'
  destinations$id <- as.character(destinations$id)


    # estimate travel time matrix
    ttm <- travel_time_matrix(r5r_core = r5r_core,
                              origins = origins,
                              destinations = destinations,
                              mode = mode,
                              mode_egress = mode_egress,
                              departure_datetime = departure_datetime,
                              time_window = time_window,
                              # percentiles = percentiles,
                              max_walk_time = max_walk_time,
                              max_bike_time = max_bike_time,
                              max_car_time = max_car_time,
                              max_trip_duration = max_trip_duration,
                              walk_speed = walk_speed,
                              bike_speed = bike_speed,
                              max_rides = max_rides,
                              max_lts = max_lts,
                              draws_per_minute = draws_per_minute,
                              n_threads = n_threads,
                              verbose = verbose,
                              progress = progress
                              )


    # aggregate travel-times
    # ttm[, isochrone_interval := cut(x=travel_time_p50, breaks=cutoffs)]
    ttm[, isochrone := cut(x=travel_time_p50, breaks=cutoffs, labels=F)]
    ttm[, isochrone := cutoffs[cutoffs>0][isochrone]]

    # check if there are at least 3 points to build a
    if (isTRUE(polygon_output)) {

      check_number_destinations <- ttm[, .(count= .N ), by=.(from_id, isochrone) ]
      temp_ids <- subset(check_number_destinations, count<3)$from_id

      if(length(temp_ids)>0){
        stop(paste0("Problem in the following origin points: ",
                    paste0(temp_ids, collapse = ', '),". These origin points are probably located in areas where the road density is too low to create proper isochrone polygons and/or the time cutoff is too short. In this case, we strongly recommend setting `polygon_output = FALSE` or setting longer cutoffs."))
      }

    }

    ### fun to get isochrones for each origin
    # polygon-based isochrones
      prep_iso_poly <- function(orig){ # orig = '89a90128107ffff'

      temp_ttm <- subset(ttm, from_id == orig)

      # join ttm results to destinations
      dest <- subset(destinations, id %in% temp_ttm$to_id)
      data.table::setDT(dest)[, id := as.character(id)]
      dest[temp_ttm, on=c('id' ='to_id'), c('travel_time_p50', 'isochrone') := list(i.travel_time_p50, i.isochrone)]

      # build polygons with {concaveman}
      # obs. {isoband} is much slower
      dest <- sf::st_as_sf(dest)

      get_poly <- function(cut){ # cut = 30
        temp <- subset(dest, travel_time_p50 <= cut)

        temp_iso <- concaveman::concaveman(temp)
        temp_iso$isochrone <- cut
        return(temp_iso)
      }
      iso_list <- lapply(X=cutoffs[cutoffs>0], FUN=get_poly)
      iso <- data.table::rbindlist(iso_list)
      iso[, id := orig]
      iso <- iso[ order(-isochrone), ]
      data.table::setcolorder(iso, c('id', 'isochrone'))
      # iso <- sf::st_as_sf(iso)
      # plot(iso)
      return(iso)
    }


    # line-based isochrones
      prep_iso_lines <- function(orig){ # orig = '89a90128107ffff'

        temp_ttm <- subset(ttm, from_id == orig)

        # join ttm results to destinations
        temp_iso <- subset(network_e, edge_index %in% temp_ttm$to_id)
        data.table::setDT(temp_iso)[, edge_index := as.character(edge_index)]
        temp_iso[temp_ttm, on=c('edge_index' ='to_id'), c('travel_time_p50', 'isochrone') := list(i.travel_time_p50, i.isochrone)]
       # temp_iso <- sf::st_as_sf(temp_iso)

      temp_iso <- temp_iso[order(-isochrone, -travel_time_p50)]
      data.table::setcolorder(temp_iso, c('edge_index', 'osm_id', 'isochrone', 'travel_time_p50'))
      # plot(temp_iso)
      return(temp_iso)
    }


    # get the isocrhone from each origin
    prep_iso <- ifelse(isTRUE(polygon_output), prep_iso_poly, prep_iso_lines)
    iso_list <- lapply(X = unique(origins$id), FUN = prep_iso)

    # put output together
    iso <- data.table::rbindlist(iso_list)
    iso <- sf::st_sf(iso)
    iso <- subset(iso, isochrone < Inf)

    # remove data.table from class
    class(iso) <- c("sf", "data.frame")
    return(iso)
  }



--------------------------------------------------------------------------------
File: java_utils.R

java_to_dt <- function(obj) {

  # check input
  if(class(obj)[1] != "jobjRef"){
    stop("Input must be an object of class 'jobjRef'")}

  # get column names from Java table
  columns <- obj$getColumnNames()

  # get the contents of each column in a vector, and return them in a list
  dt <- lapply(columns, function(column_name) {
    # check column data type, so we can call the appropriate Java function
    column_type <- obj$getColumnType(column_name)

    if (column_type == "String") { v <- obj$getStringColumn(column_name) }
    if (column_type == "Integer") { v <- obj$getIntegerColumn(column_name) }
    if (column_type == "Long") { v <- obj$getLongColumn(column_name) }
    if (column_type == "Double") { v <- obj$getDoubleColumn(column_name) }
    if (column_type == "Boolean") { v <- obj$getBooleanColumn(column_name) }
    return(v)
  })

  # convert list of vectors to a data.table, and rename columns accordingly
  data.table::setDT(dt)
  data.table::setnames(dt, new = columns)
}



--------------------------------------------------------------------------------
File: onLoad.R

# initial message about ram memory
.onAttach <- function(lib, pkg) {
  packageStartupMessage(
    "Please make sure you have already allocated ",
    "some memory to Java by running:\n",
    "  options(java.parameters = '-Xmx2G').\n",
    "You should replace '2G' by the amount of memory you'll require. ",
    "Currently, Java memory is set to ", getOption("java.parameters")
    )
  }

# package global variables
r5r_env <- new.env(parent = emptyenv())

.onLoad <- function(lib, pkg) {

  # JAR version
  r5r_env$r5_jar_version <- "7.1.0"
  r5r_env$r5_jar_size <- 63494047

  # create dir to store R5 Jar
  cache_d <- paste0('r5r/r5_jar_v', r5r_env$r5_jar_version)
  r5r_env$cache_dir <- tools::R_user_dir(cache_d, which = 'cache')
  if (!dir.exists(r5r_env$cache_dir)) dir.create(r5r_env$cache_dir, recursive = TRUE)
  # gsub("\\\\", "/", r5r_env$cache_dir)

  ## delete any JAR files from old releases
  dir_above <- dirname(r5r_env$cache_dir)
  all_cache <- list.files(dir_above, pattern = 'r5',full.names = TRUE)
  old_cache <- all_cache[!grepl(r5r_env$r5_jar_version, all_cache)]
  if(length(old_cache)>0){ unlink(old_cache, recursive = TRUE) }

}



--------------------------------------------------------------------------------
File: pareto_frontier.R

pareto_frontier <- function(r5r_core,
                            origins,
                            destinations,
                            mode = c("WALK", "TRANSIT"),
                            mode_egress = "WALK",
                            departure_datetime = Sys.time(),
                            time_window = 10L,
                            percentiles = 50L,
                            max_walk_time = Inf,
                            max_bike_time = Inf,
                            max_car_time = Inf,
                            max_trip_duration = 120L,
                            fare_structure = NULL,
                            fare_cutoffs = -1L,
                            walk_speed = 3.6,
                            bike_speed = 12,
                            max_rides = 3,
                            max_lts = 2,
                            n_threads = Inf,
                            verbose = FALSE,
                            progress = FALSE,
                            output_dir = NULL) {

  old_options <- options(datatable.optimize = Inf)
  on.exit(options(old_options), add = TRUE)

  old_dt_threads <- data.table::getDTthreads()
  dt_threads <- ifelse(is.infinite(n_threads), 0, n_threads)
  data.table::setDTthreads(dt_threads)
  on.exit(data.table::setDTthreads(old_dt_threads), add = TRUE)

  # check inputs and set r5r options --------------------------------------

  checkmate::assert_class(r5r_core, "jobjRef")

  origins <- assign_points_input(origins, "origins")
  destinations <- assign_points_input(destinations, "destinations")
  mode_list <- assign_mode(mode, mode_egress)
  departure <- assign_departure(departure_datetime)

  # check availability of transit services on the selected date
  if (mode_list$transit_mode %like% 'TRANSIT|TRAM|SUBWAY|RAIL|BUS|CABLE_CAR|GONDOLA|FUNICULAR') {
    check_transit_availability_on_date(r5r_core, departure_date = departure$date)
  }

  max_walk_time <- assign_max_street_time(
    max_walk_time,
    walk_speed,
    max_trip_duration,
    "walk"
  )
  max_bike_time <- assign_max_street_time(
    max_bike_time,
    bike_speed,
    max_trip_duration,
    "bike"
  )
  max_car_time <- assign_max_street_time(
    max_car_time,
    8, # 8 km/h, R5's default.
    max_trip_duration,
    "car"
  )
  max_trip_duration <- assign_max_trip_duration(
    max_trip_duration,
    mode_list,
    max_walk_time,
    max_bike_time
  )

  set_time_window(r5r_core, time_window)
  set_percentiles(r5r_core, percentiles)
  set_monte_carlo_draws(r5r_core, 1, time_window)
  set_speed(r5r_core, walk_speed, "walk")
  set_speed(r5r_core, bike_speed, "bike")
  set_max_rides(r5r_core, max_rides)
  set_max_lts(r5r_core, max_lts)
  set_n_threads(r5r_core, n_threads)
  set_verbose(r5r_core, verbose)
  set_progress(r5r_core, progress)
  set_fare_structure(r5r_core, fare_structure)
  set_output_dir(r5r_core, output_dir)
  set_fare_cutoffs(r5r_core, fare_cutoffs)

  # call r5r_core method and process result -------------------------------

  frontier <- r5r_core$paretoFrontier(
    origins$id,
    origins$lat,
    origins$lon,
    destinations$id,
    destinations$lat,
    destinations$lon,
    mode_list$direct_modes,
    mode_list$transit_mode,
    mode_list$access_mode,
    mode_list$egress_mode,
    departure$date,
    departure$time,
    max_walk_time,
    max_bike_time,
    max_car_time,
    max_trip_duration
  )

  if (!verbose & progress) cat("Preparing final output...", file = stderr())

  frontier <- java_to_dt(frontier)

  if (nrow(frontier) > 0) {
    # replace travel-times of nonviable trips with NAs
    frontier[travel_time > max_trip_duration, travel_time := NA_integer_]
  }

  if (!verbose & progress) cat(" DONE!\n", file = stderr())

  if (!is.null(output_dir)) return(output_dir)
  return(frontier[])
}



--------------------------------------------------------------------------------
File: r5r_cache.R

r5r_cache <- function(list_files = TRUE,
                      delete_file = NULL){

  # check inputs
  checkmate::assert_logical(list_files)
  checkmate::assert_character(delete_file, null.ok = TRUE)

  # find / create local dir
  if (!dir.exists(r5r_env$cache_dir)) { dir.create(r5r_env$cache_dir, recursive=TRUE) }

  # list cached files
  files <- list.files(dirname(r5r_env$cache_dir), full.names = TRUE, recursive = TRUE)

  # if wants to delete file
  # delete_file = "r5-v7.0-all.jar"
  if (!is.null(delete_file)) {

    # IF file does not exist, print message
    if (!any(grepl(delete_file, files)) & delete_file != "all") {
      message(paste0("The file '", delete_file, "' is not cached."))
    }

    # IF file exists, delete file
    if (any(grepl(delete_file, files))) {
      f <- files[grepl(delete_file, files)]
      unlink(f, recursive = TRUE, force = TRUE)
      message(paste0("The file '", delete_file, "' has been removed."))
    }

    # Delete ALL file
    if (delete_file=='all') {

      # delete any files from censobr, current and old data releases
      dir_above <- dirname(r5r_env$cache_dir)
      unlink(dir_above, recursive = TRUE, force = TRUE)
      message(paste0("All files have been removed."))

    }
  }

  # list cached files
  files <- list.files(r5r_env$cache_dir, full.names = TRUE)

  # print file names
  if(isTRUE(list_files)){
    message('Files currently chached:')
    message(paste0(files, collapse = '\n'))
  }
}




--------------------------------------------------------------------------------
File: r5r_sitrep.R

r5r_sitrep <- function() {
  r5r_package_version <- utils::packageVersion("r5r")

  jar_dir <- r5r_env$cache_dir
  jar_dir_files <- list.files(jar_dir)
  jar_dir_files_full_names <- list.files(jar_dir, full.names = TRUE)

  r5r_jar <- jar_dir_files[grepl("r5r_\\d_\\d_\\d.*\\.jar", jar_dir_files)]

  r5r_jar_version <- r5r_env$r5_jar_version
  r5r_jar_path <- jar_dir_files_full_names[
    grepl("\\/r5r_\\d_\\d_\\d*\\.jar", jar_dir_files_full_names)
  ]

  r5_jar <- jar_dir_files[grepl("r5-v\\d\\.\\d.*\\.jar", jar_dir_files)]
  r5_jar_version <- substr(r5_jar, 5, 7)
  r5_jar_path <- jar_dir_files_full_names[
    grepl("\\/r5-v\\d\\.\\d.*\\.jar", jar_dir_files_full_names)
  ]

  rJava::.jinit()
  java_version <- rJava::.jcall(
    "java.lang.System",
    "S",
    "getProperty",
    "java.version"
  )

  set_memory <- getOption("java.parameters")

  output_list <- list(r5r_package_version,
                      r5_jar_version,
                      java_version,
                      # r5_jar_path,
                      # r5r_jar_path,
                      set_memory,
                     # jar_dir_files_full_names,
                      utils::sessionInfo())

  names(output_list) <- c('r5r_package_version',
                          'r5_jar_version',
                          'java_version',
                         # 'r5_jar_path',
                         # 'r5r_jar_path',
                          'set_memory',
                         # 'jar_dir_files_full_names',
                          'session_info'
                          )


  return(output_list)
}



--------------------------------------------------------------------------------
File: r5r.R

"_PACKAGE"

if (getRversion() >= "2.15.1") {
  utils::globalVariables(
    c(
      "duration",
      "from_id",
      "to_id",
      "option",
      ".SD",
      "geometry",
      "route",
      "temp_duration",
      "temp_route",
      "route",
      "temp_sign",
      ".I",
      "segment_duration",
      "total_duration",
      "wait",
      "release_date",
      "con",
      "start_lon",
      "start_lat",
      "end_lon",
      "end_lat",
      "slope",
      "lat",
      "lon",
      "walk_multiplier",
      "bike_multiplier",
      "found",
      ".",
      "%>%",
      ":=",
      "%like%",
      "%chin%",
      "set",
      "travel_time",
      "id_orig",
      "lat_orig",
      "lon_orig",
      "id_dest",
      "lat_dest",
      "lon_dest",
      "i.lon",
      "i.lat",
      "total_time",
      "setting",
      "cutoff",
      'travel_time_p50',
      'id',
      'i.travel_time_p50',
      'i.isochrone',
      'edge_index',
      'count',
      'active_on_date'
    )
  )
}



--------------------------------------------------------------------------------
File: set.R

set_verbose <- function(r5r_core, verbose) {
  checkmate::assert_logical(verbose, len = 1, any.missing = FALSE)

  if (verbose) {
    r5r_core$verboseMode()
  } else {
    r5r_core$silentMode()
  }

  return(invisible(TRUE))
}


set_progress <- function(r5r_core, progress) {
  checkmate::assert_logical(progress, len = 1, any.missing = FALSE)

  r5r_core$setProgress(progress)

  return(invisible(TRUE))
}


set_n_threads <- function(r5r_core, n_threads) {
  checkmate::assert_number(n_threads, lower = 1)

  if (is.infinite(n_threads)) {
    r5r_core$setNumberOfThreadsToMax()
  } else {
    n_threads <- as.integer(n_threads)
    r5r_core$setNumberOfThreads(n_threads)
  }

  return(invisible(TRUE))
}


set_max_lts <- function(r5r_core, max_lts) {
  checkmate::assert_number(max_lts)

  if (max_lts < 1 | max_lts > 4) {
    stop(
      max_lts,
      " is not a valid value for the maximum Level of Transit Stress (LTS).\n",
      "Please enter a value between 1 and 4."
    )
  }

  r5r_core$setMaxLevelTrafficStress(as.integer(max_lts))

  return(invisible(TRUE))
}


set_max_rides <- function(r5r_core, max_rides) {
  checkmate::assert_number(max_rides, lower = 1, finite = TRUE)

  r5r_core$setMaxRides(as.integer(max_rides))

  return(invisible(TRUE))
}


set_speed <- function(r5r_core, speed, mode) {
  checkmate::assert(
    checkmate::check_string(mode),
    checkmate::check_names(mode, subset.of = c("bike", "walk")),
    combine = "and"
  )
  var_name <- paste0(mode, "_speed")
  checkmate::assert_number(speed, finite = TRUE, .var.name = var_name)
  if (speed <= 0) {
    stop(
      "Assertion on '", var_name, "' failed: Must have value greater than 0."
    )
  }

  speed <- speed * 5 / 18

  if (mode == "walk") {
    r5r_core$setWalkSpeed(speed)
  } else {
    r5r_core$setBikeSpeed(speed)
  }

  return(invisible(TRUE))
}


set_time_window <- function(r5r_core, time_window) {
  checkmate::assert_number(time_window, lower = 1, finite = TRUE)

  time_window <- as.integer(time_window)

  r5r_core$setTimeWindowSize(time_window)

  return(invisible(TRUE))
}


set_percentiles <- function(r5r_core, percentiles) {
  checkmate::assert_numeric(
    percentiles,
    lower = 1,
    upper = 99,
    max.len = 5,
    unique = TRUE,
    any.missing = FALSE,
    finite = TRUE
  )

  percentiles <- as.integer(percentiles)

  r5r_core$setPercentiles(percentiles)

  return(invisible(TRUE))
}


set_monte_carlo_draws <- function(r5r_core, draws_per_minute, time_window) {
  # time_window is previously checked in set_time_window()
  checkmate::assert_number(draws_per_minute, lower = 1, finite = TRUE)

  draws <- time_window * draws_per_minute
  draws <- as.integer(draws)

  r5r_core$setNumberOfMonteCarloDraws(draws)

  return(invisible(TRUE))
}


set_fare_structure <- function(r5r_core, fare_structure) {
  if (!is.null(fare_structure)) {
    assert_fare_structure(fare_structure)

    if (!("type" %in% names(fare_structure))) {
      # this is an R5R fare structure object
      if (fare_structure$fare_cap == Inf) {
        fare_structure$fare_cap <- -1
      }
      if (fare_structure$transfer_time_allowance == Inf) {
        fare_structure$transfer_time_allowance <- -1
      }
      if (fare_structure$max_discounted_transfers == Inf) {
        fare_structure$max_discounted_transfers <- -1
      }
    }

    fare_settings_json <- jsonlite::toJSON(fare_structure, auto_unbox = TRUE)
    json_string <- as.character(fare_settings_json)

    r5r_core$setFareCalculator(json_string)
  } else {
    r5r_core$dropFareCalculator()
  }

  return(invisible(TRUE))
}


set_max_fare <- function(r5r_core, max_fare) {
  checkmate::assert_number(max_fare, lower = 0)

  # Inf values are not allowed in Java, so -1 is used to indicate when max_fare
  # is unconstrained

  if (!is.infinite(max_fare)) {
    r5r_core$setMaxFare(rJava::.jfloat(max_fare))
  } else {
    r5r_core$setMaxFare(rJava::.jfloat(-1.0))
  }

  return(invisible(TRUE))
}


set_output_dir <- function(r5r_core, output_dir) {
  checkmate::assert_string(output_dir, null.ok = TRUE)

  if (!is.null(output_dir)) {
    checkmate::assert_directory_exists(output_dir)
    r5r_core$setCsvOutput(output_dir)
  } else {
    r5r_core$setCsvOutput("")
  }

  return(invisible(TRUE))
}


set_cutoffs <- function(r5r_core, cutoffs, decay_function) {
  checkmate::assert_numeric(
    cutoffs,
    min.len = 1,
    max.len = 12,
    any.missing = FALSE,
    finite = TRUE,
    null.ok = TRUE
  )

  non_null_cutoffs <- c("step", "exponential", "linear", "logistic")
  if (!is.null(cutoffs) & decay_function == "fixed_exponential") {
    stop(
      "Assertion on cutoffs failed: must be NULL when decay_function ",
      "is ", decay_function, "."
    )
  } else if (is.null(cutoffs) & decay_function %in% non_null_cutoffs) {
    stop(
      "Assertion on cutoffs failed: must not be NULL when decay_function ",
      "is ", decay_function, "."
    )
  }

  # java does not accept NULL values, so if cutoffs is NULL we assign a
  # placeholder number to it (it's ignored in R5 anyway)

  if (is.null(cutoffs)) {
    cutoffs <- 0L
  } else {
    cutoffs <- as.integer(cutoffs)
  }

  r5r_core$setCutoffs(cutoffs)

  return(invisible(TRUE))
}


set_fare_cutoffs <- function(r5r_core, fare_cutoffs) {
  checkmate::assert_numeric(
    fare_cutoffs,
    lower = 0,
    any.missing = FALSE,
    min.len = 1,
    unique = TRUE
  )

  r5r_core$setFareCutoffs(rJava::.jfloat(fare_cutoffs))

  return(invisible(TRUE))
}


set_breakdown <- function(r5r_core, breakdown) {
  checkmate::assert_logical(breakdown, any.missing = FALSE, len = 1)

  r5r_core$setTravelTimesBreakdown(breakdown)

  return(invisible(TRUE))
}


set_expanded_travel_times <- function(r5r_core, expanded) {
  checkmate::assert_logical(expanded, any.missing = FALSE, len = 1)

  r5r_core$setExpandedTravelTimes(expanded)

  return(invisible(TRUE))
}


set_suboptimal_minutes <- function(r5r_core,
                                   suboptimal_minutes,
                                   fare_structure,
                                   shortest_path) {
  checkmate::assert_number(suboptimal_minutes, lower = 0, finite = TRUE)

  if (!is.null(fare_structure) && suboptimal_minutes > 0) {
    stop(
      "Assertion on 'suboptimal_minutes' failed: Must be 0 when calculating ",
      "fares with detailed_itineraries()."
    )
  }

  if (shortest_path && suboptimal_minutes > 0) {
    stop(
      "Assertion on 'suboptimal_minutes' failed: Must be 0 when ",
      "'shortest_path' is TRUE."
    )
  }

  suboptimal_minutes <- as.integer(suboptimal_minutes)

  r5r_core$setSuboptimalMinutes(suboptimal_minutes)

  return(invisible(TRUE))
}



--------------------------------------------------------------------------------
File: setup_r5.R

setup_r5 <- function(data_path,
                     verbose = FALSE,
                     temp_dir = FALSE,
                     elevation = "TOBLER",
                     overwrite = FALSE) {

  # check inputs ------------------------------------------------------------

  checkmate::assert_directory_exists(data_path)
  checkmate::assert_logical(verbose)
  checkmate::assert_logical(temp_dir)
  checkmate::assert_character(elevation)
  checkmate::assert_logical(overwrite)

  elevation <- toupper(elevation)
  if (!(elevation %in% c('TOBLER', 'MINETTI','NONE'))) {
    stop("The 'elevation' parameter only accepts one of the following: c('TOBLER', 'MINETTI','NONE')")
    }


  # check Java version installed locally ---------------------------------------

  rJava::.jinit()
  ver <- rJava::.jcall("java.lang.System", "S", "getProperty", "java.version")
  ver <- as.numeric(gsub("\\..*", "", ver))
  if (ver != 21) {
    stop(
      "This package requires the Java SE Development Kit 21.\n",
      "Please update your Java installation. ",
      "The jdk 21 can be downloaded from either:\n",
      "  - openjdk: https://jdk.java.net/java-se-ri/21\n",
      "  - oracle: https://docs.oracle.com/en/java/javase/21/install/index.html"
    )
  }

  # expand data_path to full path, as required by rJava api call
  data_path <- path.expand(data_path)

  # check if data_path has osm.pbf, .tif gtfs data, or a network.dat file
  any_network <- length(grep("network.dat", list.files(data_path))) > 0
  any_pbf  <- length(grep(".pbf", list.files(data_path))) > 0
  any_gtfs <- length(grep(".zip", list.files(data_path))) > 0
  any_tif <- length(grep(".tif", list.files(data_path))) > 0

  # stop if there is no input data
  if (!(any_pbf | any_network)){
    stop("\nAn OSM PBF file is required to build a network.")
    }

  # use no elevation model if there is no raster.tif input data
  if (!(any_tif)) {
    elevation <- 'NONE'
    message("No raster .tif files found. Using elevation = 'NONE'.")
    }

  # check if the most recent JAR release is stored already.
  fileurl <- fileurl_from_metadata( r5r_env$r5_jar_version )
  filename <- basename(fileurl)

  jar_file <- data.table::fifelse(
    temp_dir,
    file.path(tempdir(), filename),
    file.path( r5r_env$cache_dir, filename)
  )

  # If there isn't a JAR already larger than 60MB, download it
  if (checkmate::test_file_exists(jar_file) && file.info(jar_file)$size > r5r_env$r5_jar_size) {
    if (!verbose) message("Using cached R5 version from ", jar_file)
  } else {
  check  <- download_r5(temp_dir = temp_dir, quiet = !verbose)
  if (is.null(check)) { return(invisible(NULL)) }
  }

  # r5r jar
  r5r_jar <- system.file("jar/r5r.jar", package = "r5r")
  rJava::.jaddClassPath(path = r5r_jar)

  # R5 jar
  rJava::.jaddClassPath(path = jar_file)

  # JRI jar
  jri_jar <- system.file("jri/JRI.jar", package="rJava")
  rJava::.jaddClassPath(path = jri_jar)

  # check if data_path already has a network.dat file
  dat_file <- file.path(data_path, "network.dat")

  if (checkmate::test_file_exists(dat_file) && !overwrite) {

    r5r_core <- rJava::.jnew("org.ipea.r5r.R5RCore", data_path, verbose, elevation)

    message("\nUsing cached network.dat from ", dat_file)

  } else {
    # check if the user has permission to write to the data directory. if not,
    # R5 won't be able to create the required files and will fail with a
    # not-that-enlightening error
    error_if_no_write_permission(data_path)

    # stop r5 in case it is already running
    suppressMessages( r5r::stop_r5() )

    # clean up any files that might have been created by previous r5r usage
    # if the files do not exist 'file.remove()' will raise a warning, which is
    # suppressed here
    mapdb_files <- list.files(data_path, full.names = TRUE)
    mapdb_files <- mapdb_files[grepl("\\.mapdb", mapdb_files)]
    suppressWarnings(
      invisible(file.remove(dat_file, mapdb_files))
    )

    # build new r5r_core
    r5r_core <- rJava::.jnew("org.ipea.r5r.R5RCore", data_path, verbose, elevation, check=F)
    ex = rJava::.jgetEx(clear=T)
    if (!is.null(NULL)) {
      ex$printStackTrace()
      return(NULL)
    }

    # display a message if there is a PBF file but no GTFS data
    if (any_pbf == TRUE & any_gtfs == FALSE) {
      message(paste("\nNo public transport data (gtfs) provided.",
                    "Graph will be built with the street network only."))
    }

    message("\nFinished building network.dat at ", dat_file)

  }

  return(r5r_core)

}

error_if_no_write_permission <- function(data_path) {
  write_permission <- file.access(data_path, mode = 2)

  normalized_path <- normalizePath(data_path)

  if (write_permission == -1) {
    cli::cli_abort(
      c(
        "Permission to write to {.path {normalized_path}} denied.",
        i = paste0(
          "{.pkg r5r} needs write privilege to create the network files. ",
          "Please make sure you have this privilege in the provided directory."
        )
      ),
      class = "dir_permission_denied",
      call = rlang::caller_env()
    )
  }

  return(invisible(TRUE))
}



--------------------------------------------------------------------------------
File: stop_r5.R

stop_r5 <- function(...) {

  supplied_cores <- list(...)

  # find all running r5r cores in the parent frame

  current_objects <- mget(ls(envir = parent.frame()), envir = parent.frame())

  classes_list <- lapply(current_objects, class)

  running_cores <- current_objects[which(classes_list == "jobjRef")]

  # if no cores have been supplied, remove all running cores
  # else, remove matches between running and supplied cores

  if (length(supplied_cores) == 0) {

    rm(list = names(running_cores), envir = parent.frame())

    message("All r5r cores have been successfully stopped.")

  } else {

    matches_supplied <- running_cores[running_cores %in% supplied_cores]

    # if a match has been found, stop it
    # else, a non r5r core object has been supplied, which raises a warning

    if (length(matches_supplied) >= 1) {

      rm(list = names(matches_supplied), envir = parent.frame())

      message(paste0(paste(names(matches_supplied), collapse = ", "),
                     " has been successfully stopped."))

    } else {

      unknown_object <- current_objects[current_objects %in% supplied_cores]

      warning(paste0(paste(names(unknown_object), collapse = ", "),
                     " is not a r5r core object."))

    }

  }

  rJava::.jgc()

}



--------------------------------------------------------------------------------
File: street_network_to_sf.R

street_network_to_sf <- function(r5r_core) {

  # check input
  if(class(r5r_core)[1] != "jobjRef"){
  stop("Input must be an object of class 'jobjRef' built with 'r5r::setup_r5()'")}

  # Get street network from R5R core
  network <- r5r_core$getStreetNetwork()

  # Convert vertices to SF (point)
  vertices_df <- java_to_dt(network$get(0L))
  vertices_sf <- sfheaders::sf_point(vertices_df, x='lon', y='lat', keep = TRUE)
  sf::st_crs(vertices_sf) <- 4326 # WGS 84

  # Convert edges to SF (linestring)
  edges_df <- java_to_dt(network$get(1L))
  edges_df[, geometry := sf::st_as_sfc(geometry)]
  edges_sf <- sf::st_sf(edges_df, crs = 4326) # WGS 84

  # gather in a list
  street_network <- list(vertices = vertices_sf, edges = edges_sf)

  return(street_network)
}



--------------------------------------------------------------------------------
File: transit_network_to_sf.R

transit_network_to_sf <- function(r5r_core) {
  checkmate::assert_class(r5r_core, "jobjRef")

  network <- r5r_core$getTransitNetwork()

  # Convert edges to SF (linestring)
  routes_df <- java_to_dt(network$get(0L))
  routes_df[, geometry := sf::st_as_sfc(geometry)]
  routes_sf <- sf::st_sf(routes_df, crs = 4326) # WGS 84

  if (any(!sf::st_is_valid(routes_sf))) {
    routes_sf <- sf::st_make_valid(routes_sf)
  }

  routes_sf <- routes_sf[!sf::st_is_empty(routes_sf), ] # removing empty geometries

  # Convert stops to SF (point)
  stops_df <- java_to_dt(network$get(1L))
  stops_df[
    ,
    `:=`(
      lat = data.table::fifelse(lat == -1, NA_real_, lat),
      lon = data.table::fifelse(lon == -1, NA_real_, lon)
    )
  ]
  stops_sf <- sfheaders::sf_point(stops_df, x = "lon", y = "lat", keep = TRUE)
  sf::st_crs(stops_sf) <- 4326 # WGS 84

  transit_network <- list(stops = stops_sf, routes = routes_sf)

  return(transit_network)
}



--------------------------------------------------------------------------------
File: travel_time_matrix.R

travel_time_matrix <- function(r5r_core,
                               origins,
                               destinations,
                               mode = "WALK",
                               mode_egress = "WALK",
                               departure_datetime = Sys.time(),
                               time_window = 10L,
                               percentiles = 50L,
                               fare_structure = NULL,
                               max_fare = Inf,
                               max_walk_time = Inf,
                               max_bike_time = Inf,
                               max_car_time = Inf,
                               max_trip_duration = 120L,
                               walk_speed = 3.6,
                               bike_speed = 12,
                               max_rides = 3,
                               max_lts = 2,
                               draws_per_minute = 5L,
                               n_threads = Inf,
                               verbose = FALSE,
                               progress = FALSE,
                               output_dir = NULL) {

  old_options <- options(datatable.optimize = Inf)
  on.exit(options(old_options), add = TRUE)

  checkmate::assert_number(n_threads, lower = 1)

  old_dt_threads <- data.table::getDTthreads()
  dt_threads <- ifelse(is.infinite(n_threads), 0, n_threads)
  data.table::setDTthreads(dt_threads)
  on.exit(data.table::setDTthreads(old_dt_threads), add = TRUE)

  # check inputs and set r5r options --------------------------------------

  checkmate::assert_class(r5r_core, "jobjRef")

  origins <- assign_points_input(origins, "origins")
  destinations <- assign_points_input(destinations, "destinations")
  mode_list <- assign_mode(mode, mode_egress)
  departure <- assign_departure(departure_datetime)

  # check availability of transit services on the selected date
  if (mode_list$transit_mode %like% 'TRANSIT|TRAM|SUBWAY|RAIL|BUS|CABLE_CAR|GONDOLA|FUNICULAR') {
    check_transit_availability_on_date(r5r_core, departure_date = departure$date)
  }

  max_walk_time <- assign_max_street_time(
    max_walk_time,
    walk_speed,
    max_trip_duration,
    "walk"
  )
  max_bike_time <- assign_max_street_time(
    max_bike_time,
    bike_speed,
    max_trip_duration,
    "bike"
  )
  max_car_time <- assign_max_street_time(
    max_car_time,
    8, # 8 km/h, R5's default.
    max_trip_duration,
    "car"
  )
  max_trip_duration <- assign_max_trip_duration(
    max_trip_duration,
    mode_list,
    max_walk_time,
    max_bike_time
  )

  set_time_window(r5r_core, time_window)
  set_percentiles(r5r_core, percentiles)
  set_monte_carlo_draws(r5r_core, draws_per_minute, time_window)
  set_speed(r5r_core, walk_speed, "walk")
  set_speed(r5r_core, bike_speed, "bike")
  set_max_rides(r5r_core, max_rides)
  set_max_lts(r5r_core, max_lts)
  set_n_threads(r5r_core, n_threads)
  set_verbose(r5r_core, verbose)
  set_progress(r5r_core, progress)
  set_fare_structure(r5r_core, fare_structure)
  set_max_fare(r5r_core, max_fare)
  set_output_dir(r5r_core, output_dir)
  set_expanded_travel_times(r5r_core, FALSE)
  set_breakdown(r5r_core, FALSE)

  # call r5r_core method and process result -------------------------------

  travel_times <- r5r_core$travelTimeMatrix(
    origins$id,
    origins$lat,
    origins$lon,
    destinations$id,
    destinations$lat,
    destinations$lon,
    mode_list$direct_modes,
    mode_list$transit_mode,
    mode_list$access_mode,
    mode_list$egress_mode,
    departure$date,
    departure$time,
    max_walk_time,
    max_bike_time,
    max_car_time,
    max_trip_duration
  )

  if (!verbose & progress) cat("Preparing final output...", file = stderr())

  travel_times <- java_to_dt(travel_times)

  if (nrow(travel_times) > 0) {
    # replace travel-times of nonviable trips with NAs.
    # the first column with travel time information is column 3, because
    # columns 1 and 2 contain the ids of OD point.
    # the percentiles parameter indicates how many travel times columns we'll
    # have
    for (j in seq(from = 3, to = (length(percentiles) + 2))) {
      data.table::set(
        travel_times,
        i = which(travel_times[[j]] > max_trip_duration),
        j = j,
        value = NA_integer_
      )
    }
  }

  if (!verbose & progress) cat(" DONE!\n", file = stderr())

  if (!is.null(output_dir)) return(output_dir)
  return(travel_times[])
}



--------------------------------------------------------------------------------
File: utils.R

fileurl_from_metadata <- function(version = NULL) {

  # R5 version
  if(is.null(version)) {version = r5r_env$r5_jar_version}

  checkmate::assert_string(version)

  metadata <- system.file("extdata/metadata_r5r.csv", package = "r5r")
  metadata <- data.table::fread(metadata)

  # check for invalid 'version' input

  if (!(version %in% metadata$version)) {
    stop(
      "Error: Invalid value to argument 'version'. ",
      "Please use one of the following: ",
      paste(unique(metadata$version), collapse = "; ")
    )
  }

  # check which jar file to download based on the 'version' parameter

  env <- environment()
  metadata <- metadata[version == get("version", envir = env)]
  metadata <- metadata[release_date == max(release_date)]
  url <- metadata$download_path
  return(url)

}


check_transit_availability_on_date <- function(r5r_core,
                                               departure_date){

  # check services Available on the departure date
  services <- r5r_core$getTransitServicesByDate(departure_date)
  services <- java_to_dt(services)

  # count services available
  data.table::setDT(services)
  services_available <- services[, sum(active_on_date) / .N ]

  if (services_available == 0) {
    cli::cli_abort("There are no transit services available on the selected departure
               date: {.val {departure_date}}. Please ensure your departure date falls
               within the GTFS calendar.")
  }


  if (services_available < 0.2) {
    cli::cli_alert_warning("Less than 20% of the transit services in the GTFS are running
                   on the selected departure date.")
  }
}



